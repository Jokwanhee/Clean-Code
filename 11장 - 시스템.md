# 시스템
> 복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다.   
[레이 오지, 마이크로소프트 최고 기술 책임자(CTO)]   
___
- []()
___
## 1. 도시를 세운다면?
- 당신들이 도시를 세운다면?
- 온갖 세세한 사항을 혼자서 직접 관리할 수 있을까?

도시에는 큰 그림을 그리는 사람들도 있으며 작은 사항에 집중하는 사람들도 있다.

도시가 돌아가는 이유는 적절한 추상화와 모듈화 때문이다. 흔히 소프트웨어 팀도 도시처럼 구성한다.
- 이를 이루면 추상화 수준에서 관심사를 분리하기 쉬워진다.

이 장에서는 높은 추상화 수준, 즉 시스템 수준에서도 깨끗함을 유지하는 방법을 살펴본다.
## 2. 시스템 제작과 시스템 사용을 분리하라
> 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 '연결'하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다.
- 시작 단계는 **관심사**이다.

대다수가 관심사를 분리하지 않는다. 코드를 주먹구구식으로 구현할 뿐만 아니라 런타임 로직과 마구 뒤섰는다.
- 대표적인 예이다.
```java
public Service getService() {
    if (service == null) {
        service = new MyServiceImpl();
    }
    return service
}
```
위 service 객체는 초기화 지연 혹은 계산 지연이라는 기법이다.

**초기화 지연의 장점**
- 실제로 필요할 때까지 객체를 생성하지 않는다. 즉, 불필요한 부하가 걸리지 않고, 애플리케이션을 시작하는 시간이 그만큼 빨라진다.
- 어떤 경우에도 null 포인터를 반환하지 않는다.

하지만 getService 메서드가 MyServiceImpl 과 생성자 인수에 명시적으로 의존한다.

일반 런타임 로직에다 객체 생성 로직을 섞어놓은 탓에 (service가 null 인 경로와 null이 아닌 경로 등) 모든 실행 경로도 테스트 해야한다. 책임이 둘이라는 말은 메서드가 작업을 두 가지 이상 수행한다. 즉, 작게나마 단일 책임 원칙(SRP)를 벗어난다.

- service 가 전체 문맥을 알 필요가 있을까? 
- 과연 이 시점에서 어떤 객체를 사용할 지 알 수나 있을까?
- 현실적으로 한 객체 유형이 모든 문맥에서 적합할 가능성이 있을까?

위 세 가지 질문을 고민해봐야한다. 그렇다고 해서 초기화 지연 기법을 한 번 정도 사용한다면 별로 심각한 문제가 아니다. 하지만 이러한 기법을 수시로 사용하면, 모듈성은 저조하며 대개 중복이 심각하다.
> 체계적이고 탄탄한 시스템을 만들고 싶으면 흔히 쓰는 좀스럽고 손쉬운 기법으로 모듈성을 깨서는 안 된다. 주요 의존성을 해소하기 위한 방식, 즉 전반적이며 일관적인 방식도 필요하다.
### Main 분리
main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘긴다. 애플리케이션은 그저 객체를 사용할 뿐이다.
```kotlin
fun main() { 
    val 객체 = 객체()
    val 애플리케이션 = 애플리케이션(객체)
}

class 애플리케이션(객체) {
    // 객체 사용
}
```
### 팩토리
때로는 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다. 예를 들어, 주문 처리 시스템에서 애플리케이션은 LineItem 인스턴스를 생성해 Order에 추가한다. 이때는 [Absract Factory(추상 팩토리) 패턴](https://github.com/Jokwanhee/Clean-Code/blob/main/%5B%EC%B0%B8%EC%A1%B0%5D%203%EC%9E%A5/%EC%B6%94%EC%83%81%20%ED%8C%A9%ED%86%A0%EB%A6%AC.md)을 사용한다. 그러면 LineIteme을 생성하는 시점은 애플리케이션이 결정하지만 LineItem을 생성하는 코드는 애플리케이션이 모른다.
### 의존성 주입
사용과 제작을 분리하는 강력한 메커니즘 하나가 [의존성 주입(Dependency Injection)](https://github.com/Jokwanhee/Clean-Code/blob/main/%5B%EC%B0%B8%EC%A1%B0%5D%2010%EC%9E%A5/DIP.md)이다. 의존성 주입은 제어 역전(IoC) 기법을 의존성 관리에 적용한 메커니즘이다.
- 제어 역전에서는 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다. 새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙(SRP)을 지키게 된다.

- JNDI 검색은 의존성 주입을 '부분적으로' 구현한 기능이다. 객체는 디렉터리 서버에 이름을 제공하고 그 이름에 일치하는 서비스를 요청한다.
```JAVA
MyService myService = (MyService)(jndiContext.lookup("NameOfMyService"));
```
호출하는 객체는(반환되는 객체가 적절한 인터페이스를 구현하는 한) 실제로 반환되는 객체의 유형을 제어하지 않는다. 대신 호출하는 객체는 의존성을 능동적으로 해결한다.
- 초기화 지연으로 얻는 장점을 포기해야 하는 걸까?
    - 이 기법은 DI를 사용하더라도 때론 여전히 유용하다.

먼저 대다수 DI 컨테이너는 필요할 때까지는 객체를 생성하지 않고, 대부분은 계산 지연이나 비슷한 최적화에 쓸 수 있도록 팩토리를 호출하거나 프록시를 생성하는 방법을 제공한다. 즉, 계산 지연 기법이나 이와 유사한 최적화 기법에서 이런 메커니즘을 사용할 수 있다. 