# 객체와 자료구조
변수를 비공개(private)로 정의하는 이유가 있다. 남들이 변수에 의존하지 않게 만들고 싶어서이다.
___
- [자료 추상화](#1-자료-추상화)
- [자료/객체 비대칭](#2-자료객체-비대칭)
___
## 1. 자료 추상화
아래에 두 클래스를 보면서 한 클래스는 외부로 노출하고 다른 클래스는 구현을 완전히 숨기는 것을 살펴보자.
### 외부 노출 클래스(구체적) VS 구현을 완전히 숨기는 클래스(추상적)
- 외부 노출 클래스(구체적)
    - 아래 Point 클래스는 직교좌표계를 사용함을 한번에 알 수 있다.
```java
public class Point {
    public double x;
    public double y;
}
```
- 구현을 완전히 숨기는 클래스(추상적)
    - 왜 숨긴다고 할까? 아래 클래스를 보고 어떤 것을 의미하는 지 알 수 있나? 아니다. 점이 직교좌표계를 사용하는 지? 극좌표계를 사용하는 지? 모른다.
```java
public interface Point {
    double getX();
    double getY();
    void setCartesian(double x, double y);
    double getR();
    double getTheta();
    void setPolar(double r, double theta);
}
```
> 구현을 감추려면 추상화가 필요하다!

> 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스이다.
### 구체적인 값을 알려주는 VS 추상적인 개념을 알려주는
- 구체적인 값을 알려주는 인터페이스
```JAVA
public interface Vehicle {
    double getFuelTankCapacityInGallons();
    double getGallonsOfGasoline();
}
```
- 추상적인 개념을 알려주는 인터페이스
```java
public interface Vehicle {
    double getPercentFuelRemaining();
} 
```
### 결론
구체적인 것보다 추상적인 것이 더 좋다. 즉, 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다. 인터페이스나 조회/설정(get/set) 함수만으로는 추상화가 이뤄지지 않는다.
___
## 2. 자료/객체 비대칭
객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다. 자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.
### 절자척인 도형 VS 다형적인(객체지향) 도형(추상화)
- 절차적인 도형 클래스
```JAVA
public class Square {
    public Point topLeft;
    public double side;
}

public class Rectangle {
    public Point topLeft;
    public double height;
    public double width;
}

public class Circle {
    public Point Center;
    public double radius;
}

public class Geometry {
    public double area(Object shape) {
        if (shape instanceof Square) {
            Squrae s = (Square)shape;
        }
        else if (shape instanceof Rectangle) {
            Rectangle r = (Rectangle)shape;
        }
        else if (shape instanceof Circle) {
            Circle c = (Circle)shape;
        }
    }
}
```

- 다형적인 도형 클래스
```java
public class Square implements Shape {
    private Point topLeft;
    private double side;

    public double area() {
        return side * side;
    }
}

public class Rectangle implements Shape {
    private Point topLeft;
    private double height;
    private double width;

    public double area() {
        return height * width;
    }
}

public class Circle implements Shape {
    private Point center;
    private double radius;

    public double area() {
        return PI * radius * radius;
    }
}
```
자 이제 살펴보자.    
절차적인 방법보다 객체지향적인 방법으로 코드를 작성하는 것이 올바르다. 하지만 100%로 맞다고는 할 수 없다.
### 객체지향의 문제점
- Shape 추상화를 각 도형이 상속할 때, Shape 에 함수가 추가된다면 Shape 를 상속한 모든 클래스는 해당 함수를 호출해야만 한다. 즉, 의존성이 강하다.
```java
인터페이스 Shape {
    함수 area();
    // draw 함수를 새로 추가한다면?
    함수 draw();
} 

클래스 Circle 상속 Shape {
    오버라이딩 함수 area();
    // 추가로 진행!
    오버라이딩 함수 draw();
}
```
### 절차지향의 문제점
- 객체지향에서 만약에 수박모양의 도형의 클래스를 만들 때는 Shape 를 상속하여 오버라이딩하며 진행할 수 있다. 하지만 절차지향은 새로운 자료구조 즉, 수박모양의 도형 클래스를 만들려면 모든 함수와 변수를 생성해야 한다.
```java
클래스 삼각형 {
    함수 삼각형그리기();
    함수 삼각형보여주기();
}

// 만약에 새로운 도형(자료구조) 추가한다면?
클래스 수박모양 {
    함수 수박그리기();
    함수 수박보여주기();
}
```
### 결론
다시 말해, 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다. 이 의미는 서로 상호보완적이 특질이 있다.   
즉, 복잡한 시스템은 객체 지향 기법이 올바르며 단순한 자료 구조는 절차적인 코드에 적합할 수 있다.