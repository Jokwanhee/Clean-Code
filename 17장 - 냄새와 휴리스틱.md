# 냄새와 휴리스틱
- [주석](#주석)
    - [부적절한 정보](#c1-부적절한-정보)
    - [쓸모 없는 주석](#c2-쓸모-없는-주석)
    - [중복된 주석](#c3-중복된-주석)
    - [성의 없는 주석](#c4-성의-없는-주석)
    - [주석 처리된 코드](#c5-주석-처리된-코드)
- [환경](#환경)
    - [여러 단계로 빌드해야 한다](#e1-여러-단계로-빌드해야-한다)
    - [여러 단계로 테스틑 해야 한다](#e2-여러-단계로-테스트-해야-한다)
- [함수](#함수)
    - [너무 많은 인수](#f1-너무-많은-인수)
    - [출력 인수](#f2-출력-인수)
    - [플래그 인수](#f3-플래그-인수)
    - [죽은 함수](#f4-죽은-함수)
- [일반](#일반)
    - [한 소스 파일에 여러 언어를 사용한다](#g1-한-소스-파일에-여러-언어를-사용한다)
    - [당연한 동작을 구현하지 않는다](#g2-당연한-동작을-구현하지-않는다)
    - [경계를 올바로 처리하지 않는다](#g3-경계를-올바로-처리하지-않는다)
    - [안전 절차 무시](#g4-안전-절차-무시)
    - [중복](#g5-중복)
    - [추상화 수준이 올바르지 못하다](#g6-추상화-수준이-올바르지-못하다)
    - [기초 클래스가 파생 클래스에 의존한다](#g7-기초-클래스가-파생-클래스에-의존한다)
    - [과도한 정보](#g8-과도한-정보)
___
## 주석
### C1. 부적절한 정보
다른 시스템에 (예를 들어, 소스 코드 관리 시스템, 버그 추적 시스템, 이슈 추적 시스템, 기타 기록 관리 시스템에) 저장할 정보는 주석으로 적절하지 못하다.

일반적으로 작성자, 최종 수정일, SRP(Software Problem Report)번호 등과 같은 메타 정보만 주석으로 넣는다.
### C2. 쓸모 없는 주석
쓸모 없어질 주석은 아예 달지 않는 편이 좋다. 코드와 무관하게 혼자서 따로 놀며 코드를 그릇된 방향으로 이끈다.
### C3. 중복된 주석
다음 주석은 좋은 예이다.
```JAVA
i++; // i 증가
```
또 다른 예가 함수 서명만 달랑 기술하는 Javadoc이다.
```java
/**
 * @param sellRequest
 * @return
 * @throws ManagedComponentException */
public SellRequest beginSellItem(SellRequest sellRequest) 
throws ManagedComponentException
```
주석은 코드만으로 다하지 못하는 설명을 부언한다.
### C4. 성의 없는 주석
주석을 달거면 시간을 들여 최대한 멋지게 작성한다. 단어를 신중하게 선택한다. 문법과 구두점을 올바로 사용한다. 주절대재 말고, 당연한 소리를 반복하지 않는다. 간결하고 명료해야 한다.
### C5. 주석 처리된 코드
주석으로 처리된 코드를 발견하면 즉각 지워버려라! 걱정할 필요 없다. 소스 코드 관리 시스템이 기억하니까. 누군가 필요하다면 이전 버전을 불러오면 된다.
## 환경
### E1. 여러 단계로 빌드해야 한다
온갖 JAR 파일, XML 파일, 기타 시스템에 필요한 파일을 찾느라 여기저기 뒤적일 필요가 없어야 한다. 한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다.
### E2. 여러 단계로 테스트 해야 한다
모든 단위 테스트는 한 명령으로 돌려야 한다. 모든 테스트를 한 번에 실행하는 능력은 아주 근본적이고 아주 중요하다. 따라서 그 방법이 빠르고, 쉽고, 명백해야 한다.
## 함수
### F1. 너무 많은 인수
함수에서 인수 개수는 작을수록 좋다. 아예 없으면 가장 좋다. 다음은 인수가 하나, 둘, 셋 ... 차례로 좋다.
### F2. 출력 인수
함수에서 뭔가의 상태를 변경해야 한다면 (출력 인수를 쓰지 말고) 함수가 속한 객체의 상태를 변경한다.
### F3. 플래그 인수
플래그 인수는 혼란을 초래하므로 피해야 마땅하다.
### F4. 죽은 함수
아무도 호출하지 않는 함수는 삭제한다. 죽은 코드는 낭비다. 과감히 삭제하라.
## 일반
### G1. 한 소스 파일에 여러 언어를 사용한다
이상적으로 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다. 현실적으로는 여러 언어가 불가피하다. 하지만 각별한 노력을 기울여 소스 파일에서 언어 수와 범위를 최대한 줄이도록 애써야 한다.
### G2. 당연한 동작을 구현하지 않는다
최소 놀람의 원칙에 의거해 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다. 예를 들어, 요일 문자열에서 요일을 나타내는 enum으로 변환하는 함수를 살펴보자.
```JAVA
Day day = DayDate.StringToDay(String dayName);
```
우리는 함수가 `Monday`를 `Day.MONDAY`로 변환하리라 기대한다.
### G3. 경계를 올바로 처리하지 않는다
개발자들은 자신의 직관에 의존할 뿐 모든 경계와 구석진 곳에서 코드를 증명하려 애쓰지 않는다. 스스로의 직관에 의존하지 마라. 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 케이스를 작성하라.
### G4. 안전 절차 무시
안전 절차를 무시하면 위험하다. 체르노벌 원전 사고는 책임자가 안전 절차를 차례로 무시하는 바람에 일어났다. 실패하는 테스트 케이스를 일단 제껴두고 나중으로 미루는 태도는 신용카드가 공짜 돈이라는 생각만큼 위험하다.
### G5. 중복
이 책에 나오는 가장 중요한 규칙 중 하나이다. 데이비드와 앤디 헌트는 이를 DRY(Don't Repeat Yourself) 원칙이라 한다.

추상화로 중복을 정리하라. 그러면 설계 언어의 어휘가 늘어난다. 추상화 수준을 높였으므로 구현이 빨라지고 오류가 적어진다.

프로그래머가 미친듯이 마우스로 긁어다 여기저기로 복사한 듯이 보이는 코드다. 이런 중복은 간단한 함수로 교체한다.

여러 모듈에서 일련의 switch/case 나 if/else 문으로 똑같은 조건을 거듭 확인하는 중복이다. 이런 중복은 다형성으로 대체해야 한다.

알고리즘이 유사하나 코드가 서로 다른 중복이다. 중복은 중복이므로 TEMPLATE METHOD 패턴이나 STRATEGY 패턴으로 중복을 제거한다.

결론은 어디서든 중복을 발견하면 없애라.

### G6. 추상화 수준이 올바르지 못하다
예를 들어보자. 세부 구현과 관련한 상수, 변수, 유틸리티 함수는 기초 클래스에 넣으면 안 된다. 기초 클래스는 구현 정보에 무지해야 마땅하다.

소스 파일, 컴포넌트, 모듈도 마찬가지다. 우수한 소프트웨어 설계자는 개념을 다양한 차원으로 분리해 다른 컨테이너에 넣는다. 때로는 기초 클래스와 파생 클래스로 분리하고, 때로는 소스 파일과 모듈과 컴포넌트로 분리한다. 어느 경우든 철저히 분리해야 한다. 고차원 개념과 저차원 개념을 섞어서는 안된다.

코드를 살펴보자.
```JAVA
public interface Stack {
    Object pop() throws EmptyException;
    void push(Object o) throws FullException;
    double percentFull();
    class EmptyException extends Exception {}
    class FullException extends Exception {}
}
```
`percentFull` 함수는 추상화 수준이 올바르지 못하다. Stack을 구현하는 방법은 다양하다. 그러므로 `percentFull` 함수는 BoundedStack과 같은 파생 인터페이스에 넣어야 마땅하다.

크기가 무한한 스택은 0을 반환하면 되지 않는가? 하지만 진정으로 무한한 스택은 존재하지 않는다. 

다음 코드는 스택 크기를 확인했다는 이유만으로 OutOfMemoryException 예외가 절대 발생하지 않으리라 장담하지 못한다.
```java
stack.percentFull() < 50.0;
```
그러므로 0을 반환하면 거짓말을 하는 셈이다.

다시 말해, 잘못된 추상화 수준은 거짓말이나 꼼수로 해결하지 못한다. 추상화는 소프트웨어 개발자에게 가장 어려운 작업 중 하나다. 잘못된 추상화를 임시변통으로 고치기는 불가능하다.

### G7. 기초 클래스가 파생 클래스에 의존한다.
```JAVA
// 기초 클래스
public class baseClass() {}
// 파생 클래스
public class derivationClass() extends baseClass {}
```
일반적으로 기초 클래스는 파생 클래스를 아예 몰라야 한다.

일반적으로 기초 클래스와 파생 클래스를 다른 JAP 파일로 배포하는 편이 좋다 왜냐하면 기초 JAR 파일이 파생 JAR 파일을 전혀 모른다면, 독립적인 개별 컴포넌트 단위로 시스템을 배치할 수 있다. 만약 컴포넌트를 변경한다면 해당 컴포넌트만 다시 배치하면 된다. 기초 컴포넌트까지 다시 배치할 필요가 없다. 즉, 변경이 시스템에 미치는 영향이 아주 작아지므로 현장에서 시스템을 유지보수하기가 한결 수월하게 된다.
### G8. 과도한 정보
작은 인터페이스로도 많은 동작이 가능하다. 부실하게 정의된 모듈은 인터페이스가 구질구질하다.

잘 정의된 인터페이스는 많은 함수를 제공하지 않는다. 그래서 결합도가 낮다. 부실하게 정의된 인터페이스는 반드시 호출해야 하는 온갖 함수를 제공한다. 그래서 결합도가 높다.

우수한 소프트웨어 개발자는 클래스나 모듈 인터페이스에 노출할 함수를 제한할 줄 알아야 한다. 클래스가 제공하는 메소드 수는 작을수록 좋다. 함수가 아는 변수 수도 작을수록 좋다. 클래스에 들어있는 인스턴스 변수 수도 작을 수록 좋다.

결론은 하위 클래스에서 필요하다는 이유로 protected 변수나 함수를 마구 생성하지 마라. 인터페이스를 매우 작게 그리고 매우 깐깐하게 만들어라. 정보를 제한해 결합도를 낮추어야 한다.
