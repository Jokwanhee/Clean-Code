# 함수
코드를 봤을 때, 추상화 수준도 너무 다양하고 코드도 길며 중첩된 if 문을 사용하면 이해하기 어렵다. 그렇기 때문에 메서드 몇 개를 추출하고, 이름 몇 개를 변경하고, 구조를 변경해볼 필요가 있다.
- 함수가 읽기 쉽고 이해하기 쉬운 이유는 무엇인가?
- 의도를 분명히 표현하는 함수를 어떻게 구현할 수 있을까?
- 함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?

`위 세 가지 질문에 나의 코드에서 답을 찾을 수 있어야 한다.`
___
- [작게 만들어라](#1-작게-만들어라)
- [한 가지만 해라!](#2-한-가지만-해라)
- [함 수 당 추상화 수준은 하나로!](#3-함수-당-추상화-수준은-하나로)
    - [추상화 수준]()
- [Switch 문](#4-switch-문)
    - [다형성]()
    - [SRP]()
    - [OCP]()
___
### 1. 작게 만들어라
**블록과 들여쓰기**<br>
if 문 / else 문 / while 문 등에 들어가는 블록은 한 줄이어야 한다. 이 말은 중첩 구조가 생길만큼 함수가 커져서는 안 된다는 뜻이다.
___
### 2. 한 가지만 해라!
> 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.

함수를 읽었을 때,<br>
1. 페이지가 테스트 페이지인지 판단한다.
2. 만약에 1 조건에 성립하면 설정 페이지와 해제 페이지를 넣는다.
3. 페이지를 HTML 로 렌더링한다.<BR>

지금 세 가지를 한다고 주장할 수 있다.<br>
**추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.**
그렇다면 한 가지 작업만 하는 함수는 자연스럽게 섹션을 나누기 어렵다.
___ 
### 3. 함수 당 추상화 수준은 하나로!
> 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.

근본 개념과 세부사항을 뒤섞기 시작하면, 깨어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다.

**`위에서 아래로 코드 읽기: 내려가기 규칙`**<br>
 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 이것을 **내려가기** 규칙이라고 부른다.
이렇게 되면 위에서 언급하듯이 추상화 수준이 하나인 함수를 구현하기란 쉽지 않다.<br>
 하지만 위에서 아래로 **함수문단** 를 읽어내려 가듯이 코드를 구현하면 추상화 수준을 일관되게 유지하기 쉬워진다.
___
### 4. Switch 문
switch 문은 작게 만들기 힘들며 case 분기를 하면서 '한 가지' 작업만 하는 switch 문을 만들기 어렵다.
```java
public Money calculatePay (Employee e) 
throws InvalidEmployeeType {
    switch (e.type) {
        case COMMISSIONED:
            return calculateCommissionedPay(e);
        case HOURLY:
            return calculateHourlyPay(e);
        case SALARIED:
            return calculateSalariedPay(e);
        default:
            throw new InvalidEmployeeType(e.type);
    }
}
```
위 함수에 몇 가지 문제를 지적하자
1. 함수가 길다
2. '한 가지' 작업만 수행하지 않는다.
3. SRP(Single Responsibility Principle) 를 위반한다.
4. OCP(Open Closed Principle) 를 위반한다.

이렇게 되면 새 직원 유형을 추가할 때마다 코드를 변경한다.
> 문제점을 개선하며 해결한 코드
```java
public abstract class Employee {
    public abstract boolean isPayDay();
    public abstract Money caculatePay();
    public abstract void deliverPay(Money pay); 
}
___________________
public interface EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r) 
    throws InvalidEmployeeType;
}
___________________
public class EmployeeFactoryImpl implements EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r)
    throws InvalidEmployeeType {
        switch (r.type) {
            case COMMISSIONED:
                return new CommissionedEmployee(r);
            case HOURLY:
                return new HourlyEmployee(r);
            case SALARIED;
                return new SalariedEmployee(r);
            default:
                throw new InvalidEmployeeType(r.type);
        }
    }
}
```
불가피하게 switch 문에서는 '한 가지'만 할 수 없다. 그렇기 때문에 다형성을 이용하여 다형적 객체를 생성하는 코드를 작성하는 것을 권장한다. 