# 점진적인 개선
이 장은 점전적인 개선을 보여주는 사례 연구다.

편리한 유틸리티가 없다면 main 함수로 넘어오는 문자열 배열을 직접 분석하게 된다. 
- 여러가지 훌륭한 유틸리티가 있지만 내 사정에 딱 맞는 유틸리티가 없다면?

물론 직접 짜겠다고 결심한다. 새로 짤 유틸리티를 Args라 부르겠다.
___
- [간단한 Args 사용법](#1-간단한-args-사용법)
- [Args 구현](#2-args-구현)
- [ArguemntMarshaler 인터페이스와 파생 클래스](#3-argumentmarshaler-인터페이스와-파생-클래스)
- [Args 1차 초안](#4-args--1차-초안)
    - [Args.java (1차 초안)](#argsjava-1차-초안)
    - [Args.java (boolean만 지원하는 버전)](#argsjavaboolean-만-지원하는-버전)
    - [Args.java (boolean과 string, string 인수 유형 추가)](#argsjavaboolean-과-string-string-인수-유형-추가)
- [Args.java 끝에 추가한 ArgumentMarshaler](#5-argsjava-끝에-추가한-argumentmarshaler)
- [String 인수](#6-string-인수)
    - [Args.java 끝에 추가한 ArgumentMarshaler + String 인수](#argsjava-끝에-추가한-argumentmarshaler--string-인수)
    - [Args.java 끝에 추가한 ArgumentMarshaler + Interger 인수](#argsjava-끝에-추가한-argumentmarshaler--integer-인수)
- [추상 클래스, abstract class ArgumentMarshaler](#7-추상-클래스-abstract-class-argumentmarshaler)
    - [abstract calss ArgumentMarshaler + 추상 메서드 set + Boolean 인수](#abstract-class-argumentmarshaler--추상-메서드-set--boolean-인수)
    - [abstract calss ArgumentMarshaler + get 메서드 + Boolean 인수](#abstract-class-argumentmarshaler--get-메서드--boolean-인수)
    - [abstract calss ArgumentMarshaler + get,set 메서드 + String 인수](#abstract-class-argumentmarshaler--get-set-메서드--string-인수)
    - [abstract calss ArgumentMarshaler + get,set 메서드 + Integer 인수](#abstract-class-argumentmarshaler--get-set-메서드--integer-인수)
- [Args.java 첫 번째 리팩터링 과정](#8-argsjava-첫-번째-리팩터링-과정)
- [Args.java 첫 번째 리팩터링을 끝낸 버전](#9-argsjava-첫-번째-리팩터링을-끝낸-버전)
___
## 1. 간단한 Args 사용법
```java
public static void main(String[] args) {
    try {
        Args arg = new Args("l,p#,d*", args);
        boolean logging = arg.getBoolean('l');
        int port = arg.getInt('p');
        String directory = arg.getString('d');
        executeApplication(logging, port, directory);
    } catch (ArgsException e) {
        System.out.printf("Argument error: %s\n", e.errorMessage());
    }
}
```
첫째 매개변수는 형식 또는 스키마를 지정하는 "l,p#,d"다.
1. 첫 번째 -l은 부울 인수다.
2. 두 번째 -p는 정수 인수다.
3. 세 번째 -d는 문자열 인수다.
## 2. Args 구현
```java
public class Args {
    private Map<Character, ArgumentMarshaler> marhalers;
    private Set<Character> argsFound;
    private ListIterator<String> currentArgument;

    public Args(String schema, String[] args) throws ArgsException {
        marshalers = new HashMap<Character, ArgumentMarshaler>();
        argsFound = new HashSet<Character>();

        parseSchema(schema);
        parseArgumentStrings(Arrays.asList(args));
    }

    private void parseSchema(String schema) throws ArgsException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                parseSchemaElement(element.tirm());
            }
        }
    }

    private void parseSchemaElement(String element) throws ArgsException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (elementTail.length() == 0) {
            marshalers.put(elementId, new BooleanArgumentMarshaler());
        } else if (elementTail.equals("*")) {
            marshalers.put(elementId, new StringArguemntMarshaler());
        } else if (elementTail.equals("#")) {
            marshalers.put(elementId, new IntegerArguemntMarshaler());
        } else if (elementTail.equals("##")) {
            marshalers.put(elementId, new DoubleArguemntMarshaler());
        } else if (elementTail.equals("[*]")) {
            marshalers.put(elementId, new StringArrayArguemntMarshaler());
        } else {
            throw new ArgsException(INVALID_ARGUMENT_FORMAT, elementId, elementTail);
        }
    }

    private void validateSchemaElementId(char elementId) throws ArgsException {
        if (!Character.isLetter(elementId)) {
            throw new ArgsException(INVALID_ARGUMENT_NAME, elementId, null);
        }
    }

    private void parseArgumentStrings(List<String> argsList) throws ArgsException {
        for (currentArgument = argsList.listIterator(); currentArgument.hasNext();) {
            String argsString = currentArgument.next();
            if (argString.startWith("-")) {
                parseArgumentCharacters(argString.subString(1));
            } else {
                currentArgument.previous();
                break;
            }
        }
    }

    private void parseArgumentCharacters(String argChars) throws ArgsException {
        for (int i = 0; i < argChars.length(); i++) {
            parseArgumentCharacter(argChars.charAt(i));
        }
    }

    private void parseArgumentCharacters(char argChar) throws ArgsException {
        ArgumentMarshaler m = marshalers.get(argChar);
        if (m == null) {
            throw new ArgsException(UNEXPECTED_ARGUMENT, argChar, null);
        } else {
            argsFound.add(argChar);
            try {
                m.set(currentArgument);
            } catch (ArgsException e) {
                e.setErrorArgumentId(argChar);
                throw e;
            }
        }
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public int nextArgument() {
        return currentArgument.nextIndex();
    }

    public boolean getBoolean(char arg) {
        return BooleanArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public String getString(char arg) {
        return StringArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public int getInt(char arg) {
        return IntegerArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public double getDouble(char arg) {
        return DoubleArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public String[] getStringArray(char arg) {
        return StringArrayArgumentMarshaler.getValue(marshalers.get(arg));
    }
}
```
이 코드에서 주목해야 할 것은 전체 코드를 이해하는 것보다 위에서 아래로 코드가 읽힌다는 사실이다.
## 3. ArgumentMarshaler 인터페이스와 파생 클래스
ArgumentMarshaler 인터페이스가 무엇이며 파생 클래스가 무슨 기능을 하는지 이해하라.
- ArgumentMarshaler.java
```java
public interface ArgumentMarshaler {
    void set(Interator<String> currentArgument) throws ArgsException;
}
```
- BooleanArgumentMarshaler.java
```java
public BooleanArgumentMarshaler implements ArgumentMarshaler {
    private boolean booleanValue = false;

    public void set(Iterator<String> currentArgument) throws ArgsException {
        booleanValue = true;
    }

    public static boolean getValue(ArgumentMarshaler am) {
        if (am != null && am instanceOf BooleanArgumentMarshaler) {
            return ((BooleanArgumentMarshaler) am).booleanValue;
        } else {
            return false;
        }
    }
}
```
- StringArgumentMarshaler.java
```java
public StringArgumentMarshaler implements ArgumentMarshaler {
    private String stringValue = "";

    public void set(Iterator<String> currentArgument) throws ArgsException {
        try {
            stringValue = currentArgument.next();
        } catch (NoSuchElementException e) {
            throw new ArgsException(MISSION_STRING);
        }
    }

    public static String getValue(ArgumentMarshaler am) {
        if (am != null && am instanceOf StringArgumentMarshaler) {
            return ((StringArgumentMarshaler) am).stringValue;
        } else {
            return "";
        }
    }
}
```
- IntegerArgumentMarshaler.java
```java
public IntegerArgumentMarshaler implements ArgumentMarshaler {
    private int intValue = 0;

    public void set(Iterator<String> currentArgument) throws ArgsException {
        String parameter = null;
        try {
            parameter = currentArgument.next();
            intValue = Integer.parseInt(parameter);
        } catch (NoSuchElementException e) {
            throw new ArgsException(MISSION_INTEGER);
        } catch (NumberFormatException e) {
            throw new ArgsException(INVALID_INTEGER, parameter);
        }
    }

    public static int getValue(ArgumentMarshaler am) {
        if (am != null && am instanceOf IntegerArgumentMarshaler) {
            return ((IntegerArgumentMarshaler) am).intValue;
        } else {
            return 0;
        }
    }
}
```
그 외에 Double과 StringArray도 마찬가지로 똑같은 패턴으로 파생 클래스를 만든다.

오류 코드 상수를 정의하는 ArgsException 클래스가 존재하는데, 이 부분을 짚고 넘어가보자.
- ArgsException.java
```java
public class ArgsException extends Exception {
    private char errorArgumentId = '\0';
    private String errorParameter = null;
    private ErrorCode errorCode = OK;

    public ArgsException() {}

    public ArgsException(String message) {
        super(message);
    }

    public ArgsException(ErrorCode errorCode) {
        this.errorCode = errorCode;
    }

    public ArgsException(ErrorCode errorCode, String errorParameter) {
        this.errorCode = errorCode;
        this.errorParameter = errorParameter;
    }

    public ArgsException(ErrorCode errorCode, char errorArgumentId, String errorParameter) {
        this.errorCode = errorCode;
        this.errorParameter = errorParameter;
        this.errorArgumentId = errorArgumentId;
    }

    public char getErrorArgumentId() {
        return errorArgumentId;
    }

    public void setErrorArgumentId(char errorArgumentId) {
        this.errorArgumentId = errorArgumentId;
    }

    // errorParameter와 errorCode 의 접근제한자 (getter 와 setter) 도 위와 똑같이 진행된다
    /** 
     * 
     * 
     * 
    */

    public String errorMessage() {
        switch(errorCode) {
            case OK:
                return "TILT: Should not get here.";
            case UNEXPECTED_ARGUMENT:
                return String.format("Argument -%c unexpected.", errorArgumentId);
            case MISSION_STRING:
                return String.Format("Could not find string parameter for -%c.", errorArgumentId)
            case INVALID_INTEGER:
                return //...
            //...
        }
    }

    public enum ErrorCode {
        OK, 
        INVALID_ARGUMENT_FORMAT,
        UNEXPECTED_ARGUMENT,
        INVALID_ARGUMENT_NAME,
        MISSING_STRING,
        MISSING_INTEGER,
        INVALID_INTEGER,
        MISSING_DOUBLE,
        INVALID_DOUBLE
    }

}
```
자 위 코드는 매우 간단한 코드이다. 하지만 코드의 양이 많아서 좀 당황스럽다. 그 이유는 그냥 자바 언어를 사용하기 때문이다. 근래 공부하는 코틀린은 자바 기반 언어이지만 코드의 양을 엄청 많이 줄일 수 있다는 것에 감사하다.

위 코드에서 이름을 붙인 방법, 함수 크기, 코드 형식에 각별히 주목해야 한다. 자잘한 구조나 스타일이 거슬릴지 모르겠지만 전반적으로 깔끔한 구조에 잘 짜인 프로그램으로 여겨주면 좋겠다 라고 밥 아저씨가 말했다.
### 어떻게 짰을까?
처음부터 코드를 저렇게 구현하지 않는다. 깨끗한 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 정리해야 한다는 의미이다.

대다수 신참 프로그래머는 단계적으로 개선해야한다는 충고를 충실히 따르지 않는다. 그들은 무조건 돌아가는 프로그램을 목표로 잡는다. 일단 프로그램이 '돌아가면' 다음 업무로 돌아간다. '돌아가는' 프로그램은 그 상태가 어떻든 그대로 버려둔다. 경험이 풍부한 전문 프로그래머라면 이런 행동이 전문가로서 자살 행위라는 사실을 잘 안다.
## 4. Args : 1차 초안
밥 아저씨가 맨 처음 짠 Args 클래스
### Args.java (1차 초안)
```java
public class Args {
    private String schema;
    private String[] args;
    private boolean valid = true;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, Boolean> booleanArgs = new HashMap<Character, Boolean>();
    private Map<Character, String> stringArgs = new HashMap<Character, String>();
    private Map<Character, Integer> intArgs = new HashMap<Character, Integer>();
    private Set<Character> argsFound = new HashSet<Character>();
    private int currentArgument;
    private char errorArgumentId = '\0';
    private String errorParameter = "TILT";
    private ErrorCode errorCode = ErrorCode.OK;

    private enum ErrorCode {
        OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT
    }

    public Args(String schema, String[] args) throws ParseException {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    private boolean parse() throws ParseException {
        if (schema.length() == 0 && args.length == 0) {
            return true
        }
        parseSchema();
        try {
            parseArguments();
        } catch (ArgsException e) {
        }
        return valid;
    }

    private boolean parseSchema() throws ParseException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                String trimmedElement = element.trim();
                parseSchemaElement(trimmedElement);
            }
        }
        return true;
    }

    private void parseSchemaElement(String element) throws ParseException {
        char elementId = element.charAt(0);
        String elementTail = element.subString(1);
        validateSchemaElementId(elementId)
        if (isBooleanSchemaElement(elementTail)) {
            parseBooleanSchemaElement(elementId);
        } else if (isStringSchemaElement(elementTail)) {
            parseStringSchemaElement(elementId);
        } else if (isIntegerSchemaElement(elementTail)) {
            parseIntegerSchemaElement(elementId);
        } else {
            throw new ParseException(
                String.format("Argument: %c has invalid format: %s.", 
                    elementId, elementTail), 0);
        }
    }

    private void validateSchemaElementId(char elementId) throws ParseException {
        if (!Character.isLetter(elementId)) {
            throw new ParseException(
                "Bad character:" + elementId + "in Args format: " + schema, 0
            );
        }
    }

    private void parseBooleanSchemaElement(char elementId) {
        booleanArgs.put(elementId, false);
    }

    private void parseIntegerSchemaElement(char elementId) {
        intArgs.put(elementId, 0);
    }

    private void parseStringSchemaElement(char elementId) {
        stringArgs.put(elementId, "");
    }

    private boolean isStringSchemaElement(String elementTail) {
        return elementTail.equals("*");
    }

    private boolean isBooleanSchemaElement(String elementTail) {
        return elementTail.length() == 0;
    }

    private boolean isIntegerSchemaElement(String elementTail) {
        return elementTail.equals("#");
    }

    private boolean parseArguments() throws ArgsException {
        for (currentArgument = 0; currentArgument < args.length; currentArgument++) {
            String arg = args[currentArgument];
            parseArgument(arg);
        }
        return true;
    }

    private void parseArgument(String arg) throws ArgsException {
        if (arg.startWith("-")) {
            parseElements(arg);
        }
    }

    private void parseElements(String arg) throws ArgsException {
        for (int i = 1; i < arg.length(); i++) {
            parseElement(arg.charAt(i));
        }
    }

    private void parseElement(char argChar) throws ArgsException {
        if (setArgument(argChar)) {
            argsFound.add(argChar);
        } else {
            unexpectedArguments.add(argChar);
            errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
            valid = false;
        }
    }

    private boolean setArgument(char argChar) throws ArgsException {
        if (isBooleanArg(argChar)) {
            setBooleanArg(argChar, true);
        } else if (isStringArg(argChar)) {
            setStringArg(argChar);
        } else if (isIntArg(argChar)) {
            setIntArg(argChar);
        } else {
            return false;
        }
        return true;
    }

    private boolean isIntArg(char argChar) {
        return intArgs.containsKey(argChar);
    }

    private void setIntArg(char argChar) throws ArgsException {
        currentArgument++;
        String parameter = null;
        try {
            parameter = args[currentArgument];
            intArgs.put(argChar, new Integer(parameter));
        } catch (ArrayIndexOutOfBoundsException e) {
            valid = false;
            errorArgumentId = argChar;
            errorCode = ErrorCode.MISSING_INTEGER;
            throw new ArgsException();
        } catch (NumberFormatException e) {
            valid = false;
            errorArgumentId = argChar;
            errorParameter = parameter;
            errorCode = ErrorCode.INVALID_INTEGER;
            throw new ArgsException();
        }
    }

    private void setStringArg(char argChar) throws ArgsException {
        currentArgument++;
        try {
            stringArgs.put(argChar, args[currentArgument]);
        } catch (ArrayIndexOutOfBoundsException e) {
            valid = false;
            errorArgumentId = argChar;
            errorCode = ErrorCode.MISSING_STRING;
            throw new ArgsException();
        }
    }

    private boolean isStringArg(char argChar) {
        return stringArgs.containsKey(argChar);
    }

    private void setBooleanArg(char argChar, boolean value) {
        booleanArgs.put(argChar, value);
    }

    private boolean isBooleanArg(char argChar) {
        return booleanArgs.containsKey(argChar);
    }

    public int cardinality() {
        return argsFound.size();
    }

    public String usage() {
        if (schema.length() > 0) {
            return "-[" + schema + "]";
        } else {
            return "";
        }
    }

    public String errorMessage() throws Exception {
        switch (errorCode) {
            case OK:
                throw new Exception("TILT: Should not get here.");
            case UNEXPECTED_ARGUMENT:
                return unexpectedArgumentMessage();
            case MISSING_STRING:
                return String.format("Could not find string parameter for -%c/", errorArguemntId);
            case INVALID_INTEGER:
                return String.format("Argument -%c expects and integer but was '%s'.", errorArgumentId, errorParameter);
            case MISSING_INTEGER:
                return String.format("Could not find integer parameter for -%c.", errorArgumentId);
        }
        return "";
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");

        return message.toString();
    }

    private boolean falseIfNull(Boolean b) {
        return b != null && b;
    }

    private int zeroIfNull(Integer i) {
        return i == null ? 0 : i;
    }

    private String blankIfNull(String s) {
        return s == null ? "" : s;
    }

    public String getString(char arg) {
        return blankIfNull(stringArgs.get(arg));
    }

    public int getInt(char arg) {
        return zeroIfNull(intArgs.get(arg));
    }

    public boolean getBoolean(char arg) {
        return falseIfNull(booleanArgs.get(arg));
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public boolean isValid() {
        return valid;
    }

    private class ArgsException extends Exception {
    }
}
```
Args 1차 초안을 보면 미완성된 코드라고 말할 수 있다. 인스턴스 변수 개수만도 압도적이고, 'TILT'와 같은 희한한 문자열, HashSets와 TreeSets, try-catch-catch 블록 등 모두가 지저분한 코드에 기여하는 요인이다.

위 코드에서는 나름 함수 이름이나 변수 이름을 선택한 방식, 어설프지만 나름대로 구조가 있다는 사실 등이 밥 아저씨의 노력이 보인다.

Boolean 인수만 지원하던 초기 버전이다.
### Args.java(Boolean 만 지원하는 버전)
```java
public class Args {
    private String schema;
    private String[] args;
    private boolean valid;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, Boolean> booleanArgs = new HashMap<Character, Boolean>();
    private int numberOfArguments = 0;

    public Args(String schema, String[] args) {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    public boolean isValid() {
        return valid;
    }

    private boolean parse() {
        if (schema.length() == 0 && args.length == 0) {
            return true;
        }
        parseSchema();
        parseArguments();
        return unexpectedArguments.size() == 0;
    }

    private boolean parseSchema() {
        for (String element : schema.split(",")) {
            parseSchemaElement(element);
        }
        return true;
    }

    private void parseSchemaElement(String element) {
        if (element.length() == 1) {
            parseBooleanSchemaElement(element);
        }
    }

    private void parseBooleanSchemaElement(String element) {
        char c = element.charAt(0);
        if (Character.isLetter(c)) {
            booleanArgs.put(c, false);
        }
    }

    private boolean parseArguments() {
        for (String arg : args) {
            parseArgument(arg);
        }
        return true;
    }

    private void parseArgument(String arg) {
        if (arg.startsWith("-")) {
            parseElements(arg);
        }
    }

    private void parseElements(String arg) {
        for (int i = 1; i < arg.length(); i++) {
            parseElement(arg.charAt(i));
        }
    }

    private void parseElement(char argChar) {
        if (isBoolean(argChar)) {
            numberOfArguments++;
            setBooleanArg(argChar, true);
        } else {
            unexpectedArguments.add(argChar);
        }
    }

    private void setBooleanArg(char argChar, boolean value) {
        booleanArgs.put(argChar, value);
    }

    private boolean isBoolean(char argChar) {
        return booleanArgs.containsKey(argChar);
    }

    public int cardinality() {
        return numberOfArguments;
    }

    public String usage() {
        if (schema.length() > 0) {
            return "-[" + schema + "]";
        } else {
            return "";
        }
    }

    public String errorMessage() {
        if (unexpectedArguments.size() > 0) {
            return unexpectedArgumentMessage();
        } else {
            return "";
        }
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");

        return message.toString();
    }

    public boolean getBoolean(char arg) {
        return booleanArgs.get(arg);
    }
}
```
위 코드가 많다고 생각할 수 있지만 나름대로 괜찮은 코드이다. 간결하고 단순하며 이해하기도 쉽다. 근데 뭔가 지저분해질 것 같은 기분이 든다. 
- 나중에 엉망으로 코드가 변할 요소는?

바로 위 코드에 String, Interger 라는 인수 유형 두 개만 추가했을 뿐인데, 코드가 엄청나게 지저분해지는 것을 알 수 있다. 위에서 Boolean 으로 처리된 메서드를 똑같이 String, Integer 인수 유형의 메서드도 추가 되어야 한다...

이는 유지와 보수가 적당히 수월 했던 코드가 버그와 결함이 숨어있을지도 모른다는 상당히 의심스러운 코드로 뒤바뀌어버린 것이다.

그래서 준비했다. String 인수 유형을 추가한 다음 코드이다.
### Args.java(Boolean 과 String, String 인수 유형 추가)
```java
public class Args {
    private String schema;
    private String[] args;
    private boolean valid = true;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, Boolean> booleanArgs = new HashMap<Character, Boolean>();
    private Map<Character, String> stringArgs = new HashMap<Character, String>();
    private Set<Character> argsFound = new HashSet<Character>();
    private int currentArgument;
    private char errorArgument = '\0';

    enum ErrorCode {
        OK, MISSING_STRING
    }

    private ErrorCode errorCode = ErrorCode.OK;

    public Args(String schema, String[] args) throws ParseException {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    private boolean parse() throws ParseException {
        if (schema.length() == 0 && args.length == 0) {
            return true;
        }
        parseSchema();
        parseArguments();
        return valid;
    }

    private boolean parseSchema() throws ParseException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                String trimmedElement = element.trim();
                parseSchemaElement(trimmedElement);
            }
        }
        return true;
    }

    private void parseSchemaElement(String element) throws ParseException {
        char elementId = element.charAt(0);
        String elementTail = element.subString(1);
        validateSchemaElementId(elementId);
        if (isBooleanSchemaElement(elementTail)) {
            parseBooleanSchemaElement(elementId);
        } else if (isStringSchemaElement(elementTail)) {
            parseStringSchemaElement(elementId);
        }
    }

    private void validateSchemaElementId(char elementId) throws ParseException {
        if (!Character.isLetter(elementId)) {
            throw new ParseException(
                "Bad character:" + elementId + "in Args format: " + schema, 0
            );
        }
    }

    private void parseStringSchemaElement(char elementId) {
        stringArgs.put(elementId, "");
    }

    private boolean isStringSchemaElement(String elementTail) {
        return elementTail.equals("*");
    }

    private boolean isBooleanSchemaElement(String elementTail) {
        return elementTail.length() == 0;
    }

    private void parseBooleanSchemaElement(char elementId) {
        booleanArgs.put(elementId, false);
    }

    private boolean parseArguments() {
        for (currentArgument = 0; currentArgument < args.length; currentArgument++) {
            String arg = args[currentArgument];
            parseArgument(arg);
        }
        return true;
    }

    private void parseArgument(String arg) {
        if (arg.startsWith("-")) {
            parseElements(arg);
        }
    }

    private void parseElements(String arg) {
        for (int i = 1; i < arg.length(); i++) {
            parseElement(arg.charAt(i));
        }
    }

    private void parseElement(char argChar) {
        if (setArgument(argChar)) {
            argsFound.add(argChar);
        } else {
            unexpectedArguments.add(argChar);
            valid = false;
        }
    }

    private boolean setArgument(char argChar) {
        boolean set = true;
        if (isBoolean(argChar)) {
            setBooleanArg(argChar, true);
        } else if (isString(argChar)) {
            setStringArg(argChar, "");
        } else {
            set = false;
        }

        return false;
    }

    private void setStringArg(char argChar, String s) {
        currentArgument++;
        try {
            stringArgs.put(argChar, args[currentArgument]);
        } catch (ArrayIndexOutOfBoundsException e) {
            valid = false;
            errorArgument = argChar;
            errorCode = ErrorCode.MISSING_STRING;
        }
    }

    private boolean isString(char argChar) {
        return stringArgs.containsKey(argChar);
    }

    private void setBooleanArg(char argChar, boolean value) {
        booleanArgs.put(argChar, value);
    }

    private boolean isBoolean(char argChar) {
        return booleanArgs.containsKey(argChar);
    }

    public int cardinality() {
        return argsFound.size();
    }

    public String usage() {
        if (schema.length() > 0) {
            return "-[" + schema + "]";
        } else {
            return "";
        }
    }

    public String errorMessage() throws Exception {
        if (unexpectedArguments.size() > 0) {
            return unexpectedArgumentMessage();
        } else {
            switch (errorCode) {
                case MISSING_STRING:
                    return String.format("Could not find string parameter for -%c.", errorArgument);
                case OK:
                    throw new Exception("TILT: Should not get here.");
            }
        }
        return "";
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");

        return message.toString();
    }

    public boolean getBoolean(char arg) {
        return falseIfNull(booleanArgs.get(arg));
    }

    private boolean falseIfNull(Boolean b) {
        return b == null ? false : b;
    }

    public String getString(char arg) {
        return blankIfNull(stringArgs.get(arg));
    }

    private String blankIfNull(String s) {
        return s == null ? "" : s;
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public boolean isValid() {
        return valid;
    }
}
```
String 인수 유형이 추가되었지만 아직까지는 읽을만하다. 하지만 새로운 인수 Integer 유형이 추가된다면 코드가 엄청 길어진다. 즉, 코드가 엉망이 되며 오류가 발생한다면 결함을 찾기 어려워진다.
### 그래서 멈췄다.
추가할 인수 유형이 적어도 두 개는 더 있었는데 코드가 더 나빠질것을 예상하고 멈추고 코드 구조를 유지보수하기 좋은 상태로 만들려면지금이 적기라 판단된 것이다.

기능을 추가하지 않고 리팩터링을 시작한다.

- 첫째, 인수 유형에 해당하는 HashMap을 성택하기 위해 스키마 요소의 구문을 분석한다.
- 둘째, 명령행 인수에서 인수 유형을 분석해 진짜 유형으로 변환한다.
- 셋째, getXXX 메서드를 구현해 호출자에게 진짜 유형을 반환한다.
### 점진적으로 개선하다
 프로그램을 망치는 가장 좋은 방법 중 하나는 개선이라는 이름 아래 구조를 크게 뒤집는 행위다. 어떤 프로그램은 그저 그런 '개선'에서 결코 회복하지 못한다. '개선'전과 똑같이 프로그램을 돌리기가 아주 어렵기 때문이다.

 그래서 테스트 주도 개발(TDD)이라는 기법을 사용할 수 있다.

 ## 5. Args.java 끝에 추가한 ArgumentMarshaler
 ```java
 private class ArgumentMarshaler {
    private boolean booleanValue = false;

    public void setBoolean(boolean value) {
        booleanValue = value;
    }

    public boolean getBoolean() { return booleanValue; }
}

private class BooleanArgumentMarshaler extends ArgumentMarshaler {}
private class StringArgumentMarshaler extends ArguemntMarshaler {}
private class IntegerArgumentMarshaler extends ArgumentMarshaler {}
 ```

Boolean 인수를 저장하는 HashMap 에서 Boolean 인수 유형을 ArgumentMarshaler 유형으로 바꾼다.
```java
private Map<Character, ArgumentMarshaler> booleanArgs = 
    new HashMap<Character, ArgumentMarshaler>();
```
이렇게 바뀌면 코드가 일부 깨지므로 코드를 고쳐야 한다.
```java
private void parseBooleanSchemaElement(char elementId) {
    booleanArgs.put(elementId, new BooleanArgumentMarshaler());
}
```
```java
private void setBooleanArgs(char argChar, boolean value) {
    booleanArgs.get(argChar).setBoolean(value);
}
```
```java
public boolean getBoolean(char arg) {
    return falseIfNull(booleanArgs.get(arg).getBoolean());
}
```
새 인수 유형을 추가하면서 parse, get set 부분 메서드를 변경해야 한다. 사소한 변경이었지만 위에 코드는 몇몇 테스트 케이스가 실패하기 시작한다. getBoolean 함수를 살펴볼 수 있다.
```java
falseIfNull()
```
falseIfNull 메서드를 주목해야 한다. 우리는 HashMap 에서 Boolean 인수 유형을 ArgumentMarshaler 유형으로 바꾸었다. 이는 null 을 반환하게 되며, NullPointerException 을 던진다.

고치는 방법은 어렵지 않다. null 점검 위치만 변경해주면 된다.
```java
public boolean getBoolean(char arg) {
    return booleanArgs.get(arg).getBoolean();
}
```
기차 충돌 코드를 피하기 위해서 변수를 사용하는 것이 좋을 것 같은 생각이 든다. 그리고 긴 변수명은 싫고 유형 이름과 중복이 심했고 함수가 길어졌으니 짧은 변수명을 생각해야 한다.
```java
public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = booleanArgs.get(arg);
    return am.getBoolean();
}
```
그 다음 null을 점검하면 된다.
```java
public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = booleanArgs.get(arg);
    return am != null && am.getBoolean();
}
```
## 6. String 인수
String 인수를 추가하는 과정은 boolean 인수와 매우 유사하다. HashMap을 변경한 후 parse, set, get 함수를 고치면 된다.

### Args.java 끝에 추가한 ArgumentMarshaler + String 인수
```java
private Map<Character, ArgumentMarshaler> stringArgs = 
    new HashMap<Character, ArgumentMarshaler>();
```
```java
private void parseStringSchemaElement(char elementId) {
    stringArgs.put(elementId, new StringArgumentMarshaler());
}
```
```java
private void setStringArg(char argChar) throws ArgsException {
    currentArgument++;
    try {
        stringArgs.get(argChar).setString(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
        valid = false;
        errorArgumentId = argChar;
        errorCode = ErrorCode.MISSING_STRING;
        throw new ArgsException();
    }
}
```
```java
public String getString(char arg) {
    Args.ArgumentMarshaler am = stringArgs.get(arg);
    return am == null ? "" : am.getString();
}
```
```java
private class ArgumentMarshaler {
    private String stringValue;

    public void setString(String s) {
        stringValue = s;
    }

    public String getString() {
        return stringValue == null ? "" : stringValue;
    }
}
```
의도를 눈치챘는가? 

일단 각 인수 유형을 처리하는 코드를 모두 ArgumentMarshaler 클래스에 넣고 나서 ArgumentMarshaler 파생 클래스를 만들어 코드를 분리할 작정인 것이다. 그러면 프로그램 구조를 조금씩 변경하는 동안에도 시스템의 정상 동작을 유지하기 쉬워지기 때문이다.

### Args.java 끝에 추가한 ArgumentMarshaler + Integer 인수
```java
private Map<Character, ArgumentMarshaler> intArgs =
    new HashMap<Character, ArgumentMarshaler>();
```
```java
private void parseIntegerSchemaElement(char elementId) {
    intArgs.put(elementId, new IntegerArgumentMarshaler());
}
```
```java
private void setIntArg(char argChar) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
        parameter = args[currentArgument];
        intArgs.get(argChar).setInteger(Integer.parseInt(parameter));
    } catch (ArrayIndexOutOfBoundsException e) {
        valid = false;
        errorArgumentId = argChar;
        errodCode = ErrorCode.MISSING_INTEGER;
        throw new ArgsException();
    } catch (NumberFormatException e) {
        valid = false;
        errorArgumentId = argChar;
        errorParameter = parameter;
        errorCode = ErrorCode.INALID_INTEGER;
        throw new ArgsException();
    }
}
```
```java
public int getInt(char arg) {
    Args.ArgumentMarshaler am = intArgs.get(arg);
    return am == null ? 0 : am.getInteger();
}
```
```java
private class ArgumentMarshaler {
    private int integerValue;

    public void setInteger(int i) {
        integerValue = i;
    }

    public int getInteger() {
        return integerValue;
    }
}
```
이제 boolean, string, integer 의 인수 유형을 만들어 ArgumentMarshaler 로 옮겼으니 파생 클래스를 만들어 기능을 분산할 차례이다.
- 뭔 소리야?

```java
private class BooleanArgumentMarshaler extends ArgumentMarshaler {}
private class StringArgumentMarshaler extends ArguemntMarshaler {}
private class IntegerArgumentMarshaler extends ArgumentMarshaler {}
```
위에서 ArgumentMarshaler 파생 클래스인 BooleanArgumentMarshaler, StringArgumentMarshaler, IntegerArgumentMarshaler 의 클래스로 각 함수를 옮기고 올바로 호출되는 지 확인하는 것이다.

## 7. 추상 클래스, abstract class ArgumentMarshaler
우선 ArgumentMarshaler 클래스에 추상 메서드 set을 만든다.
### abstract class ArgumentMarshaler + 추상 메서드 set + Boolean 인수
```java
private abstract class ArgumentMarshaler {
    protected boolean booleanValue = false;
    private String stringValue;
    private int integerValue;

    public void setBoolean(boolean value) {
        booleanValue = value;
    }

    public boolean getBoolean() {
        return booleanValue;
    }

    public void setString(String s) {
        stringValue = s;
    }

    public String getString() {
         return stringValue == null ? "" :  stringValue;
    }

    public void setInteger(int i) {
        integerValue = i;
    }

    public int getInteger() {
        return integerValue;
    }

    public abstract void set(String s);
}
```
다음으로 BooleanArgumentMarshaler 클래스에 set 메서드를 구현(오버라이딩) 한다.
```java
private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    public void set(String s) {
        booleanValue = true
    }
}
```
setBoolean 호출을 set 호출로 바꾼다.
```java
private void setBooleanArg(char argChar, boolean value) {
    booleanArgs.get(argChar).set("true");
}
```
set 기능을 BooleanArgumentMarshaler로 옮겼으니 ArgumentMarshaler에서 setBoolean 메서드를 제거했다.

다음은 get 메서드를 BooleanArgumentMarshaler로 옮겼다. get 함수는 언제나 옮기기 어렵다. 그 이유는 반환 객체 유형이 Object이여야 하기 때문이다.
### abstract class ArgumentMarshaler + get 메서드 + Boolean 인수
```java
private abstract class ArgumentMarshaler {
    public Object get() {
        return null;
    }
}
```
컴파일은 되었으나 테스트는 실패한다. 

테스트를 통과하기 위해 ArgumentMarshaler에서 get을 추상 메서드로 만든 후 BooleanArgumentMarshaler에다 get을 구현했다.
```java
private abstract class ArgumentMarshaler {
    protected boolean booleanValue = false;

    public abstract Object get();
}
```
```java
private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    public Object get() {
        return booleanValue;
    }
}
```
코드는 모든 테스틑 통과하였다! get과 set을 BooleanArgumentMarshaler로 모두 옮기는데 성공한 것이다. ArgumentMarshaler에서 사용하지 않는 getBoolean 함수를 제거한다.

### abstract class ArgumentMarshaler + get, set 메서드 + String 인수
String 인수 유형도 동일한 방식으로 변경하였다. set과 get을 옮긴 후 사용하지 않는 함수를 제거하고 변수를 옮겼다.
```java
private void setStringArgs(char argChar) throws ArgsException {
    currentArgument++;
    try {
        stringArgs.get(argChar).set(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
        valid = false;
        errorArgumentId = argChar;
        errodCode = ErrorCode.MISSING_STRING;
        throw new ArgsException();
    }
}
```
```java
public String getString(char arg) {
    Args.ArgumentMarshaler am = stringArgs.get(arg);
    return am == null ? "" : (String) am.get();
}
```
```java
private abstract class ArgumentMarshaler {
    private int integerValue;

    public void setInteger(int i) {
        integerValue = i;
    }

    public int getInteger() {
        return integerValue;
    }

    public abstract void set(String s);
    public abstract Object get();
}
```
```java
private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    private boolean booleanValue = false;

    public void set(String s) {
        booleanValue = true;
    }

    public Object get() {
        return booleanValue;
    }
}
```
```java
private class StringArgumentMarshaler extends ArgumentMarshaler {
    private String stringValue = "";

    public void set(String s) {
        stringValue = s;
    }

    public Object get() {
        return stringValue;
    }
}
```
위 코드에서 ArgumentMarshaler 클래스에서 boolean, string 인수 유형의 get, set 함수가 없어진 것을 볼 수 있고, BooleanArgumentMarshaler과 StringArgumentMarshaler 클래스에 get, set 함수를 추가한 것을 알 수 있다.

마지막으로 intgeger 인수 유형도 같은 과정을 반복하면 된다.
### abstract class ArgumentMarshaler + get, set 메서드 + Integer 인수
```java
private boolean isIntArg(char argChar) { 
    return intArgs.containsKey(argChar);
}
```
```java
private void setIntArg(char argChar) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
        parameter = args[currentArgument];
        intArgs.get(argChar).set(parameter);
    } catch (ArrayIndexOutOfBoundsException e) {
        valid = false;
        errorArgumentId = argChar;
        errorCode = ErrorCode.MISSING_INTEGER;
        throw new ArgsException();
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        errorParameter = parameter;
        errorCode = ErrorCode.INVALID_INTEGER;
        throw e;
    }
}
```
```java
private void setBooleanArg(char argChar) {
    try {
        booleanArgs.get(argChar).set("true");
    } catch (ArgsException e) {}
}
```
```java
public int getInt(char arg) {
    Args.ArgumentMarshaler am = intArgs.get(arg);
    return am == null ? 0 : (Integer) am.get();
}
```
```java
private abstract class ArgumentMarshaler {
    public abstract void set(String s) throws ArgsException;
    public abstract Object get();
}
```
```java
private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    private int intValue = 0;

    public void set(String s) throws ArgsException {
        try {
            intValue = Integer.parseInt(s);
        } catch (NumberFormatException e) {
            throw new ArgsException();
        }
    }

    public Object get() {
        return intValue;
    }
}
```
여기서 주목해야 할 부분 ArgumentMarshaler 클래스를 보면 알 수 있다. 많이 간소화 된 것을 알 수 있다.

다음으로 Args 클래스에 처음에 나오는 (인수 유형마다 따로 만든) 맵 세 개를 없앤다. 하지만 그냥 없애면 에러가 난다. 그 대신 ArgumentMarshaler로 맵을 만들어 원래 맵을 교체하고 관련 메서드를 변경했다.

## 8. Args.java (첫 번째 리팩터링 과정)
- Map 변수 변경하기
```java
public class Args {
    private Map<Character, ArgumentMarshaler> booleanArgs = 
        new HashMap<Character, ArgumentMarshaler>();
    private Map<Character, ArgumentMarshaler> stringArgs = 
        new HashMap<Character, ArgumentMarshaler>();
    private Map<Character, ArgumentMarshaler> intArgs = 
        new HashMap<Character, ArgumentMarshaler>();
}
```
```java
public class Args {
    private Map<Character, ArgumentMarshaler> marshalers =
        new HashMap<Charcter, ArgumentMarshaler>();
}
```
- 각 인수유형마다 값 넣어주는 함수 변경
```java
public class Args {
    private void parseBooleanSchemaElement(char elementId) {
        booleanArgs.put(elementId, m);
    }
    private void parseIntegerSchemaElement(char elementId) {
        intArgs.put(elementId, m);
    }
    private void parseStringSchemaElement(char elementId) {
        stringArgs.put(elementId, m);
    }
}
```
```java
public class Args {
    private void parseBooleanSchemaElement(char elementId) {
        ArgumentMarshaler m = new BooleanArgumentMarshaler();
        marshalers.put(elementId, m);
    }
    private void parseIntegerSchemaElement(char elementId) {
        ArgumentMarshaler m = new IntegerArgumentMarshaler();
        marshalers.put(elementId, m);
    }
    private void parseStringSchemaElement(char elementId) {
        ArgumentMarshaler m = new StringArgumentMarshaler();
        marshalers.put(elementId, m);
    }
}
```
- isBooleanArg 변경
```java
private boolean isBooleanArgs(char argChar) {
    return booleanArgs.containsKey(argChar);
}
```
```java
private boolean isBooleanArg(char argChar) {
    ArgumentMarshaler m = marshalers.get(argChar);
    return m instanceOf BooleanArgumentMarshaler;
}
```
- isIntArg, isStringArg 도 변경
```java
private boolean isIntArg(char argChar) {
    return intArgs.containsKey(argChar);
}
private boolean isStringArg(char argChar) {
    return stringArgs.containsKey(argChar);
}
```
```java
private boolean isIntArg(char argChar) {
    ArgumentMarshaler m = marshalers.get(argChar);
    return m instanceOf IntegerArgumentMarshaler;
}
private boolean isStringArg(char argChar) {
    ArgumentMarshaler m = marshalers.get(argChar);
    return m instanceOf StringArgumentMarshaler;
}
```

중복되는 `marshalers.get` 함수...

- marshalers.get 함수를 제거하자
```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (isBooleanArg(m)) {
        setBooleanArg(argChar);
    } else if (isStringArg(m)) {
        setStringArg(argChar);
    } else if (isIntArg(m)) {
        setIntArg(argChar);
    } else {
        return false;
    }

    return true;
}

private boolean isIntArg(ArgumentMarshaler m) {
    return m instanceOf IntegerArgumentMarshaler;
}

private boolean isStringArg(ArgumentMarshaler m) {
    return m instanceOf StringArgumentMarshaler;
}

private boolean isBooleanArgs(ArgumentMarshaler m) {
    return m instanceOf BooleanArgumentMarshaler;
}
```

근데 isXXXArgs 함수가 필요할까? 굳이 필요 없을 것 같다. 그러므로 인라임 코드로 만들어버리자.
```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m instanceOf BooleanArgumentMarshaler) {
        setBooleanArg(argChar);
    } else if (m instanceOf StringArgumentMarshaler) {
        setStringArg(argChar);
    } else if (m instanceOf IntegerArgumentMarshaler) {
        setIntArg(argChar);
    } else {
        return false;
    }

    return true;
}
```
다음으로 setXXArg 함수를 변경해보자. 기존 HashMap 을 marhshalers HashMap으로 교체하는 것을 진행한다.
- setBooleanArg 
```java
private void setBooleanArg(ArgumentMarshaler m) {
    try {
        // 이전 코드 : booleanArgs.get(argChar).set("true");
        m.set("true") ;
    } catch (ArgsException e) {
    }
}
```
String과 Integer 인수 유형도 똑같이 진행한다. 추가적으로 일부 흉한 예외 관리 코드를 setArgument 함수 넣을 수 있다.
- setStringArg, setIntArg
```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    try {
        if (m instanceOf BooleanArgumentMarshaler) {
            setBooleanArg(m);
        } else if (m instanceOf StringArgumentMarshaler) {
            setStringArg(m);
        } else if (m instanceOf IntegerArgumentMarshaler) {
            setIntArg(m);
        } else {
            return false;
        }
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        throw e;
    }
    return true;
}
```
```java
private void setStringArg(ArgumentMarshaler m) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
        parameter = args[currentArgument];
        m.set(parameter);
    } catch (ArrayIndexOutOfBoundsException e) {
        errorCode = ErrorCode.MISSING_INTEGER;
        throw new ArgsException();
    } catch (ArgsException e) {
        errorParameter = parameter;
        errorCode = ErrorCode.INVALID_INTEGER;
        throw e;
    }
}

private void setIntArg(ArgumentMarshaler m) throws ArgsException {
    currentArgument++;
    try {
        m.set(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
        errorCode = ErrorCode.MISSING_STRING;
        throw new ArgsException();
    }
}
```
이제 원래 맵 세개를 제거해도 괜찮은 시점이다. 

우선 getBoolean 함수를 변경하자.
- getBoolean
```java
public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = booleanArgs.get(arg);
    return am != null && (Boolean) am.get();
}
```
```java
public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = marshalers.get(arg);
    boolean b = false;
    try {
        b = am != null && (Boolean) am.get();
    } catch (ClassCastException e) {
        b = false;
    }
    return b;
}
```

자 이제 boolean 맵을 사용하는 코드를 제거할 수 있다. 즉, 아래 변수가 사용되었던 코드를 삭제해도 된다.
```java
booleanArgs
```

String과 Integer 인수 유형도 boolean과 마찬가지로 변경하고 이전 맵을 제거하면 된다. 그 전에 parseXXXSchemaElement 함수의 객체 할당을 하지말고 일회성 클래스 인스턴스로 사용하여 진행하자.
- parseXXXSchemaElement
```java
private void parseBooleanSchemaElement(char elementId) {
    // 이전 코드 
    // ArgumentMarshaler m = new BooleanArgumentMarshaler();
    // marshaelrs.put(elementId, m);
    marshalers.put(elementId, new BooleanArgumentMarshaler());
}

private void parseIntegerSchemaElement(char elementId) {
    marshalers.put(elementId, new IntegerArgumentMarshaler());
}

private void parseStringSchemaElement(char elementId) {
    marshalers.put(elmentId, new StringArgumentMarshaler());
}
```
- getString, getInt
```java
public String getString(char arg) {
    Args.ArgumentMarshaler am = marshalers.get(arg);
    try {
        return am == null ? "" : (String) am.get();
    } catch (ClassCastException e) {
        return "";
    }
}

public int getInt(char arg) {
    Args.ArgumentMarshaler am = marshaelrs.get(arg);
    try {
        return am == null ? 0 : (Integer) am.get();
    } catch (Exception e) {
        return 0;
    }
}
```
String, Integer 인수 유형 맵 변수 사용은 제거해도 된다.
```java
stringArgs
intArgs
```

그 다음 parseXXXSchemaElement 함수가 parseSchemaElement에 사용 될때, 함수로 사용되었는데, 이 부분도 인라인 코드로 바꾸자.
```java
private void parseSchemaElement(String element) throws ParseException {
    if (isBooleanSchemaElement(elementTail)) {
        parseBooleanSchemaElement(elementId);
    }
}
```
```java
private void parseSchemaElement(String element) throws ParseException {
    if (isBooleanSchemaElement(elementTail)) {
        marshalers.put(elementId, new BooleanArgumentMarshaler());
    }
}
```
String 과 Integer 인수 유형도 마찬가지이므로 작성하지 않았다.

## 9. Args.java (첫 번째 리팩터링을 끝낸 버전)
```java
public class Args {
    private String schema;
    private String[] args;
    private boolean valid = true;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, ArgumentMarshaler> marshalers =
        new HashMap<Character, ArgumentMarshaler>();
    private Set<Character> argsFound = new HashSet<Character>();
    private int currentArgument;
    private char errorArgumentId = '\0';
    private String errorParameter = "TILT";
    private ErrorCode errorCode = ErrorCode.OK;

    private enum ErrorCode {
        OK, MISSING_STRING, MISSING_INTEGER, 
        INVALID_INTEGER,
        UNEXPECTED_ARGUMENT
    }

    public Args(String schema, String[] args) throws ParseException {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    private boolean parse() throws ParseException {
        if (schema.length() == 0 && args.length == 0) {
            return true;
        }
        parseSchema();
        try {
            parseArguments();
        } catch (ArgsException e) {
        }
        return valid;
    }

    private boolean parseSchema() throws ParseException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                String trimmedElement = element.trim();
                parseSchemaElement(trimmedElement);
            }
        }
        return true;
    }

    private void parseSchemaElement(String element) throws ParseException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (isBooleanSchemaElement(elementTail)) {
            marshalers.put(elementId, new BooleanArgumentMarshaler());
        } else if (isStringSchemaElement(elementTail)) {
            marshalers.put(elementId, new StringArgumentMarshaler());
        } else if (isIntgerSchemaElement(elementTail)) {
            marshalers.put(elementId, new IntegerArgumentMarshaler());
        } else {
            throw new ParseException(String.format(
                "Argument: %c has invalid format: %s.", elementId, elementTail
            ), 0);
        }
    }

    private void validateSchemaElementId(char elementId) throws ParseException {
        if (!Character.isLetter(elementId)) {
            throw new ParseException(
                "Bad character:" + elementId + "in Args format: "  + schema, 0
            );
        }
    }

    private boolean isStringSchemaElement(String elementTail) {
        return elementTail.equals("*");
    }

    private boolean isBooleanSchemaElement(String elementTail) {
        return elementTail.length() == 0;
    }

    private boolean isIntegerSchemaElement(String elementTail) {
        return elementTail.equals("#");
    }

    private boolean parseArguments() throws ArgsException {
        for (currentArgument = 0; currentArgument < args.length; currentArgument++) {
            String arg = args[currentArgument];
            parseArgument(arg);
        }
        return true;
    }

    private void parseArgument(String arg) throws ArgsException {
        if (arg.startsWith("-")) {
            parseElements(arg);
        }
    }

    private void parseElements(String arg) throws ArgsException {
        for (int i = 1; i < arg.length(); i++) {
            parseElement(arg.charAt(i));
        }
    }

    private void parseElement(char argChar) throws ArgsException {
        if (setArgument(argChar)) {
            argsFound.add(argChar);
        } else {
            unexpectedArguments.add(argChar);
            errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
            valid = false;
        }
    }

    private boolean setArgument(char argChar) throws ArgsException {
        ArguemntMarshaler m = marshalers.get(argChar);
        try {
            if (m instanceOf BooleanArgumentMarshaler) {
                setBooleanArg(m);
            } else if (m instanceOf StringArgumentMarshaler) {
                setStringArg(m);
            } else if (m instanceOf IntegerArgumentMarshaler) {
                setIntArg(m);
            } else {
                return false;
            }
        } catch (ArgsException e) {
            valid = false;
            errorArgumentId = argChar;
            throw e;
        }
        return true;
    }

    private void setIntArg(ArgumentMarshaler m) throws ArgsException {
        currentArgument++;
        String parameter = null;
        try {
            parameter = args[currentArgument];
            m.set(parameter);
        } catch (ArrayIndexOutOfBoundsException e) {
            errorCode = ErrorCode.MISSING_INTEGER;
            throw new ArgsException();
        } catch (ArgsException e) {
            errorParameter = parameter;
            errorCode = ErrroCode.INVALID_INTEGER;
            throw e;
        }
    }

    private void setStringArg(ArgumentMarshaler m) throws ArgsException {
        currentArgument++;
        try {
            m.set(args[currentArgument]);
        } catch (ArrayIndexOutOfBoundsException e) {
            errorCode = ErrorCode.MISSING_STRING;
            throw new ArgsException();
        }
    }

    private void setBooleanArg(ArgumentMarshaler m) {
        try {
            m.set("true");
        } catch (ArgsException e) {
        }
    }

    public int cardinality() {
        return argsFound.size();
    }

    public String usage() {
        if (schema.length() > 0) {
            return "-[" + schema + "]";
        } else {
            return "";
        }
    }

    public String errorMessage() throws Exception {
        switch (errorCode) {
            case OK:
                return new Exception("TILT: Should not get here.");
            case UNEXPECTED_ARGUMENT:
                return unexpectedArgumentMessage();
            case MISSING_STRING:
                return String.format("Could not find string parameter for -%c.", errorArgumentId);
            case INVALID_INTEGER:
                return String.format("Argument -%c expects an integer but was '%s'.", errorArgumentId, errorParameter);
            case MISSING_INTEGER:
                return String.format("Could not find integer parameter for -%c.", errorArgumentId);
        } 
        return "";
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");

        return message.toString();
    }

    public boolean getBoolean(char arg) {
        Args.ArgumentMarshaler am = marshalers.get(arg);
        boolean b = false;
        try {
            b = am != null && (Boolean) am.get();
        } catch (ClassCastException e) {
            b = false;
        }
        return b;
    }

    public String getString(char arg) {
        Args.ArgumentMarshaler am = marshalers.get(arg);
        try {
            return am == null ? "" : (String) am.get();
        } catch (ClassCastException e) {
            return "";
        }
    }

    public int getInt(char arg) {
        Args.ArgumentMarshaler am = marshalers.get(arg);
        try {
            return am == null ? 0 : (Integer) am.get();
        } catch (Exception e) { 
            return 0;
        }
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public boolean isValid() {
        return valid;
    }

    private class ArgsException extends Exception {
    }

    private abstract class ArgumentMarshaler {
        public abstract void set(String s) throws ArgsException;
        public abstract Object get();
    }

    private class BooleanArgumentMarshaler extends ArgumentMarshaler {
        private boolean booleanValue = false;

        public void set(String s) {
            booleanValue = true;
        }

        public Object get() {
            return booleanValue;
        }
    }

    private class StringArgumentMarshaler extends ArgumentMarshaler {
        private String stringValue = "";

        public void set(String s) {
            stringValue = s;
        }

        public Object get() {
            return stringValue;
        }
    }

    private class IntegerArgumentMarshaler extends ArgumentMarshaler {
        private int intValue = 0;

        public void set(String s) throws ArgsException {
            try {
                intValue = Integer.parseInt(s);
            } catch (NumberFormatException e) {
                throw new ArgsException();
            }
        }

        public Object get() {
            return intValue;
        }
    }
}
```

그 전에 작성한 Args.java 1차 초안을 보려면 [Args.java 1차 초안](#4-args--1차-초안 )링크로 넘어가자. 그리고 Args.java 리팩토링 과정을 살펴보려면 [Args.java 리팩토링 과정](#8-argsjava-첫-번째-리팩터링-과정) 링크로 확인하자.

- 첫 번째 리팩토링은 어떤가?

다소 실망적인 코드다. 구조만 조금 나아졌다. 첫머리에 나오는 변수는 아직도 남아있으며, setArgument에는 유형을 일일이 확인하는 보기 싫은 코드도 남아있다. 게다가 모든 set함수는 정말로 흉하다. 오류 처리 코드 또한 마찬가지이다. 