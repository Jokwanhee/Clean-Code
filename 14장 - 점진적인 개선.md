# 점진적인 개선
이 장은 점전적인 개선을 보여주는 사례 연구다.

편리한 유틸리티가 없다면 main 함수로 넘어오는 문자열 배열을 직접 분석하게 된다. 
- 여러가지 훌륭한 유틸리티가 있지만 내 사정에 딱 맞는 유틸리티가 없다면?

물론 직접 짜겠다고 결심한다. 새로 짤 유틸리티를 Args라 부르겠다.
___
- [간단한 Args 사용법](#1-간단한-args-사용법)
- [Args 구현](#2-args-구현)
- [ArguemntMarshaler 인터페이스와 파생 클래스](#3-argumentmarshaler-인터페이스와-파생-클래스)
- [Args 1차 초안](#4-args--1차-초안)
    - [Args.java (1차 초안)](#argsjava-1차-초안)
    - [Args.java (boolean만 지원하는 버전)](#argsjavaboolean-만-지원하는-버전)
    - [Args.java (boolean과 string, string 인수 유형 추가)](#argsjavaboolean-과-string-string-인수-유형-추가)
- [Args.java 끝에 추가한 ArgumentMarshaler](#5-argsjava-끝에-추가한-argumentmarshaler)
- [String 인수](#6-string-인수)
    - [Args.java 끝에 추가한 ArgumentMarshaler + String 인수](#argsjava-끝에-추가한-argumentmarshaler--string-인수)
    - [Args.java 끝에 추가한 ArgumentMarshaler + Interger 인수](#argsjava-끝에-추가한-argumentmarshaler--integer-인수)
- [추상 클래스, abstract class ArgumentMarshaler](#7-추상-클래스-abstract-class-argumentmarshaler)
    - [abstract calss ArgumentMarshaler + 추상 메서드 set + Boolean 인수](#abstract-class-argumentmarshaler--추상-메서드-set--boolean-인수)
    - [abstract calss ArgumentMarshaler + get 메서드 + Boolean 인수](#abstract-class-argumentmarshaler--get-메서드--boolean-인수)
    - [abstract calss ArgumentMarshaler + get,set 메서드 + String 인수](#abstract-class-argumentmarshaler--get-set-메서드--string-인수)
    - [abstract calss ArgumentMarshaler + get,set 메서드 + Integer 인수](#abstract-class-argumentmarshaler--get-set-메서드--integer-인수)
- [Args.java 첫 번째 리팩터링 과정](#8-argsjava-첫-번째-리팩터링-과정)
- [Args.java 첫 번째 리팩터링을 끝낸 버전](#9-argsjava-첫-번째-리팩터링을-끝낸-버전)
    - [setArgument 유형 체크 제거 과정](#setargument-유형-체크-제거-과정)
    - [setArgument 유형 체크 제거 코드](#setargument-유형-체크-제거-코드)
    - [IntegerArgumentMarshaler 몇 가지 허술한 코드 고치기](#integerargumentmarshaler-몇-가지-허술한-코드-고치기)
- [새로운 인수 유형 추가 : Double](#10-새로운-인수-유형-추가---double)
    - [DoubleArgumentMarshaler 클래스](#doubleargumentmarshaler-클래스)
- [ArgsException 클래스](#11-argsexception-클래스)
- [ArgsTest.java](#12-argstestjava)
- [ArgsExceptionTest.java](#13-argsexceptiontestjava)
- [ArgsException.java](#14-argsexceptionjava)
- [Args.java (최종)](#15-argsjava-최종)
- [결론](#결론)
- [나 자신이 느낀점](#나-자신이-느낀점)
___
## 1. 간단한 Args 사용법
```java
public static void main(String[] args) {
    try {
        Args arg = new Args("l,p#,d*", args);
        boolean logging = arg.getBoolean('l');
        int port = arg.getInt('p');
        String directory = arg.getString('d');
        executeApplication(logging, port, directory);
    } catch (ArgsException e) {
        System.out.printf("Argument error: %s\n", e.errorMessage());
    }
}
```
첫째 매개변수는 형식 또는 스키마를 지정하는 "l,p#,d"다.
1. 첫 번째 -l은 부울 인수다.
2. 두 번째 -p는 정수 인수다.
3. 세 번째 -d는 문자열 인수다.
## 2. Args 구현
```java
public class Args {
    private Map<Character, ArgumentMarshaler> marhalers;
    private Set<Character> argsFound;
    private ListIterator<String> currentArgument;

    public Args(String schema, String[] args) throws ArgsException {
        marshalers = new HashMap<Character, ArgumentMarshaler>();
        argsFound = new HashSet<Character>();

        parseSchema(schema);
        parseArgumentStrings(Arrays.asList(args));
    }

    private void parseSchema(String schema) throws ArgsException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                parseSchemaElement(element.tirm());
            }
        }
    }

    private void parseSchemaElement(String element) throws ArgsException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (elementTail.length() == 0) {
            marshalers.put(elementId, new BooleanArgumentMarshaler());
        } else if (elementTail.equals("*")) {
            marshalers.put(elementId, new StringArguemntMarshaler());
        } else if (elementTail.equals("#")) {
            marshalers.put(elementId, new IntegerArguemntMarshaler());
        } else if (elementTail.equals("##")) {
            marshalers.put(elementId, new DoubleArguemntMarshaler());
        } else if (elementTail.equals("[*]")) {
            marshalers.put(elementId, new StringArrayArguemntMarshaler());
        } else {
            throw new ArgsException(INVALID_ARGUMENT_FORMAT, elementId, elementTail);
        }
    }

    private void validateSchemaElementId(char elementId) throws ArgsException {
        if (!Character.isLetter(elementId)) {
            throw new ArgsException(INVALID_ARGUMENT_NAME, elementId, null);
        }
    }

    private void parseArgumentStrings(List<String> argsList) throws ArgsException {
        for (currentArgument = argsList.listIterator(); currentArgument.hasNext();) {
            String argsString = currentArgument.next();
            if (argString.startWith("-")) {
                parseArgumentCharacters(argString.subString(1));
            } else {
                currentArgument.previous();
                break;
            }
        }
    }

    private void parseArgumentCharacters(String argChars) throws ArgsException {
        for (int i = 0; i < argChars.length(); i++) {
            parseArgumentCharacter(argChars.charAt(i));
        }
    }

    private void parseArgumentCharacters(char argChar) throws ArgsException {
        ArgumentMarshaler m = marshalers.get(argChar);
        if (m == null) {
            throw new ArgsException(UNEXPECTED_ARGUMENT, argChar, null);
        } else {
            argsFound.add(argChar);
            try {
                m.set(currentArgument);
            } catch (ArgsException e) {
                e.setErrorArgumentId(argChar);
                throw e;
            }
        }
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public int nextArgument() {
        return currentArgument.nextIndex();
    }

    public boolean getBoolean(char arg) {
        return BooleanArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public String getString(char arg) {
        return StringArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public int getInt(char arg) {
        return IntegerArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public double getDouble(char arg) {
        return DoubleArgumentMarshaler.getValue(marshalers.get(arg));
    }

    public String[] getStringArray(char arg) {
        return StringArrayArgumentMarshaler.getValue(marshalers.get(arg));
    }
}
```
이 코드에서 주목해야 할 것은 전체 코드를 이해하는 것보다 위에서 아래로 코드가 읽힌다는 사실이다.
## 3. ArgumentMarshaler 인터페이스와 파생 클래스
ArgumentMarshaler 인터페이스가 무엇이며 파생 클래스가 무슨 기능을 하는지 이해하라.
- ArgumentMarshaler.java
```java
public interface ArgumentMarshaler {
    void set(Interator<String> currentArgument) throws ArgsException;
}
```
- BooleanArgumentMarshaler.java
```java
public BooleanArgumentMarshaler implements ArgumentMarshaler {
    private boolean booleanValue = false;

    public void set(Iterator<String> currentArgument) throws ArgsException {
        booleanValue = true;
    }

    public static boolean getValue(ArgumentMarshaler am) {
        if (am != null && am instanceOf BooleanArgumentMarshaler) {
            return ((BooleanArgumentMarshaler) am).booleanValue;
        } else {
            return false;
        }
    }
}
```
- StringArgumentMarshaler.java
```java
public StringArgumentMarshaler implements ArgumentMarshaler {
    private String stringValue = "";

    public void set(Iterator<String> currentArgument) throws ArgsException {
        try {
            stringValue = currentArgument.next();
        } catch (NoSuchElementException e) {
            throw new ArgsException(MISSION_STRING);
        }
    }

    public static String getValue(ArgumentMarshaler am) {
        if (am != null && am instanceOf StringArgumentMarshaler) {
            return ((StringArgumentMarshaler) am).stringValue;
        } else {
            return "";
        }
    }
}
```
- IntegerArgumentMarshaler.java
```java
public IntegerArgumentMarshaler implements ArgumentMarshaler {
    private int intValue = 0;

    public void set(Iterator<String> currentArgument) throws ArgsException {
        String parameter = null;
        try {
            parameter = currentArgument.next();
            intValue = Integer.parseInt(parameter);
        } catch (NoSuchElementException e) {
            throw new ArgsException(MISSION_INTEGER);
        } catch (NumberFormatException e) {
            throw new ArgsException(INVALID_INTEGER, parameter);
        }
    }

    public static int getValue(ArgumentMarshaler am) {
        if (am != null && am instanceOf IntegerArgumentMarshaler) {
            return ((IntegerArgumentMarshaler) am).intValue;
        } else {
            return 0;
        }
    }
}
```
그 외에 Double과 StringArray도 마찬가지로 똑같은 패턴으로 파생 클래스를 만든다.

오류 코드 상수를 정의하는 ArgsException 클래스가 존재하는데, 이 부분을 짚고 넘어가보자.
- ArgsException.java
```java
public class ArgsException extends Exception {
    private char errorArgumentId = '\0';
    private String errorParameter = null;
    private ErrorCode errorCode = OK;

    public ArgsException() {}

    public ArgsException(String message) {
        super(message);
    }

    public ArgsException(ErrorCode errorCode) {
        this.errorCode = errorCode;
    }

    public ArgsException(ErrorCode errorCode, String errorParameter) {
        this.errorCode = errorCode;
        this.errorParameter = errorParameter;
    }

    public ArgsException(ErrorCode errorCode, char errorArgumentId, String errorParameter) {
        this.errorCode = errorCode;
        this.errorParameter = errorParameter;
        this.errorArgumentId = errorArgumentId;
    }

    public char getErrorArgumentId() {
        return errorArgumentId;
    }

    public void setErrorArgumentId(char errorArgumentId) {
        this.errorArgumentId = errorArgumentId;
    }

    // errorParameter와 errorCode 의 접근제한자 (getter 와 setter) 도 위와 똑같이 진행된다
    /** 
     * 
     * 
     * 
    */

    public String errorMessage() {
        switch(errorCode) {
            case OK:
                return "TILT: Should not get here.";
            case UNEXPECTED_ARGUMENT:
                return String.format("Argument -%c unexpected.", errorArgumentId);
            case MISSION_STRING:
                return String.Format("Could not find string parameter for -%c.", errorArgumentId)
            case INVALID_INTEGER:
                return //...
            //...
        }
    }

    public enum ErrorCode {
        OK, 
        INVALID_ARGUMENT_FORMAT,
        UNEXPECTED_ARGUMENT,
        INVALID_ARGUMENT_NAME,
        MISSING_STRING,
        MISSING_INTEGER,
        INVALID_INTEGER,
        MISSING_DOUBLE,
        INVALID_DOUBLE
    }

}
```
자 위 코드는 매우 간단한 코드이다. 하지만 코드의 양이 많아서 좀 당황스럽다. 그 이유는 그냥 자바 언어를 사용하기 때문이다. 근래 공부하는 코틀린은 자바 기반 언어이지만 코드의 양을 엄청 많이 줄일 수 있다는 것에 감사하다.

위 코드에서 이름을 붙인 방법, 함수 크기, 코드 형식에 각별히 주목해야 한다. 자잘한 구조나 스타일이 거슬릴지 모르겠지만 전반적으로 깔끔한 구조에 잘 짜인 프로그램으로 여겨주면 좋겠다 라고 밥 아저씨가 말했다.
### 어떻게 짰을까?
처음부터 코드를 저렇게 구현하지 않는다. 깨끗한 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 정리해야 한다는 의미이다.

대다수 신참 프로그래머는 단계적으로 개선해야한다는 충고를 충실히 따르지 않는다. 그들은 무조건 돌아가는 프로그램을 목표로 잡는다. 일단 프로그램이 '돌아가면' 다음 업무로 돌아간다. '돌아가는' 프로그램은 그 상태가 어떻든 그대로 버려둔다. 경험이 풍부한 전문 프로그래머라면 이런 행동이 전문가로서 자살 행위라는 사실을 잘 안다.
## 4. Args : 1차 초안
밥 아저씨가 맨 처음 짠 Args 클래스
### Args.java (1차 초안)
```java
public class Args {
    private String schema;
    private String[] args;
    private boolean valid = true;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, Boolean> booleanArgs = new HashMap<Character, Boolean>();
    private Map<Character, String> stringArgs = new HashMap<Character, String>();
    private Map<Character, Integer> intArgs = new HashMap<Character, Integer>();
    private Set<Character> argsFound = new HashSet<Character>();
    private int currentArgument;
    private char errorArgumentId = '\0';
    private String errorParameter = "TILT";
    private ErrorCode errorCode = ErrorCode.OK;

    private enum ErrorCode {
        OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT
    }

    public Args(String schema, String[] args) throws ParseException {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    private boolean parse() throws ParseException {
        if (schema.length() == 0 && args.length == 0) {
            return true
        }
        parseSchema();
        try {
            parseArguments();
        } catch (ArgsException e) {
        }
        return valid;
    }

    private boolean parseSchema() throws ParseException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                String trimmedElement = element.trim();
                parseSchemaElement(trimmedElement);
            }
        }
        return true;
    }

    private void parseSchemaElement(String element) throws ParseException {
        char elementId = element.charAt(0);
        String elementTail = element.subString(1);
        validateSchemaElementId(elementId)
        if (isBooleanSchemaElement(elementTail)) {
            parseBooleanSchemaElement(elementId);
        } else if (isStringSchemaElement(elementTail)) {
            parseStringSchemaElement(elementId);
        } else if (isIntegerSchemaElement(elementTail)) {
            parseIntegerSchemaElement(elementId);
        } else {
            throw new ParseException(
                String.format("Argument: %c has invalid format: %s.", 
                    elementId, elementTail), 0);
        }
    }

    private void validateSchemaElementId(char elementId) throws ParseException {
        if (!Character.isLetter(elementId)) {
            throw new ParseException(
                "Bad character:" + elementId + "in Args format: " + schema, 0
            );
        }
    }

    private void parseBooleanSchemaElement(char elementId) {
        booleanArgs.put(elementId, false);
    }

    private void parseIntegerSchemaElement(char elementId) {
        intArgs.put(elementId, 0);
    }

    private void parseStringSchemaElement(char elementId) {
        stringArgs.put(elementId, "");
    }

    private boolean isStringSchemaElement(String elementTail) {
        return elementTail.equals("*");
    }

    private boolean isBooleanSchemaElement(String elementTail) {
        return elementTail.length() == 0;
    }

    private boolean isIntegerSchemaElement(String elementTail) {
        return elementTail.equals("#");
    }

    private boolean parseArguments() throws ArgsException {
        for (currentArgument = 0; currentArgument < args.length; currentArgument++) {
            String arg = args[currentArgument];
            parseArgument(arg);
        }
        return true;
    }

    private void parseArgument(String arg) throws ArgsException {
        if (arg.startWith("-")) {
            parseElements(arg);
        }
    }

    private void parseElements(String arg) throws ArgsException {
        for (int i = 1; i < arg.length(); i++) {
            parseElement(arg.charAt(i));
        }
    }

    private void parseElement(char argChar) throws ArgsException {
        if (setArgument(argChar)) {
            argsFound.add(argChar);
        } else {
            unexpectedArguments.add(argChar);
            errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
            valid = false;
        }
    }

    private boolean setArgument(char argChar) throws ArgsException {
        if (isBooleanArg(argChar)) {
            setBooleanArg(argChar, true);
        } else if (isStringArg(argChar)) {
            setStringArg(argChar);
        } else if (isIntArg(argChar)) {
            setIntArg(argChar);
        } else {
            return false;
        }
        return true;
    }

    private boolean isIntArg(char argChar) {
        return intArgs.containsKey(argChar);
    }

    private void setIntArg(char argChar) throws ArgsException {
        currentArgument++;
        String parameter = null;
        try {
            parameter = args[currentArgument];
            intArgs.put(argChar, new Integer(parameter));
        } catch (ArrayIndexOutOfBoundsException e) {
            valid = false;
            errorArgumentId = argChar;
            errorCode = ErrorCode.MISSING_INTEGER;
            throw new ArgsException();
        } catch (NumberFormatException e) {
            valid = false;
            errorArgumentId = argChar;
            errorParameter = parameter;
            errorCode = ErrorCode.INVALID_INTEGER;
            throw new ArgsException();
        }
    }

    private void setStringArg(char argChar) throws ArgsException {
        currentArgument++;
        try {
            stringArgs.put(argChar, args[currentArgument]);
        } catch (ArrayIndexOutOfBoundsException e) {
            valid = false;
            errorArgumentId = argChar;
            errorCode = ErrorCode.MISSING_STRING;
            throw new ArgsException();
        }
    }

    private boolean isStringArg(char argChar) {
        return stringArgs.containsKey(argChar);
    }

    private void setBooleanArg(char argChar, boolean value) {
        booleanArgs.put(argChar, value);
    }

    private boolean isBooleanArg(char argChar) {
        return booleanArgs.containsKey(argChar);
    }

    public int cardinality() {
        return argsFound.size();
    }

    public String usage() {
        if (schema.length() > 0) {
            return "-[" + schema + "]";
        } else {
            return "";
        }
    }

    public String errorMessage() throws Exception {
        switch (errorCode) {
            case OK:
                throw new Exception("TILT: Should not get here.");
            case UNEXPECTED_ARGUMENT:
                return unexpectedArgumentMessage();
            case MISSING_STRING:
                return String.format("Could not find string parameter for -%c/", errorArguemntId);
            case INVALID_INTEGER:
                return String.format("Argument -%c expects and integer but was '%s'.", errorArgumentId, errorParameter);
            case MISSING_INTEGER:
                return String.format("Could not find integer parameter for -%c.", errorArgumentId);
        }
        return "";
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");

        return message.toString();
    }

    private boolean falseIfNull(Boolean b) {
        return b != null && b;
    }

    private int zeroIfNull(Integer i) {
        return i == null ? 0 : i;
    }

    private String blankIfNull(String s) {
        return s == null ? "" : s;
    }

    public String getString(char arg) {
        return blankIfNull(stringArgs.get(arg));
    }

    public int getInt(char arg) {
        return zeroIfNull(intArgs.get(arg));
    }

    public boolean getBoolean(char arg) {
        return falseIfNull(booleanArgs.get(arg));
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public boolean isValid() {
        return valid;
    }

    private class ArgsException extends Exception {
    }
}
```
Args 1차 초안을 보면 미완성된 코드라고 말할 수 있다. 인스턴스 변수 개수만도 압도적이고, 'TILT'와 같은 희한한 문자열, HashSets와 TreeSets, try-catch-catch 블록 등 모두가 지저분한 코드에 기여하는 요인이다.

위 코드에서는 나름 함수 이름이나 변수 이름을 선택한 방식, 어설프지만 나름대로 구조가 있다는 사실 등이 밥 아저씨의 노력이 보인다.

Boolean 인수만 지원하던 초기 버전이다.
### Args.java(Boolean 만 지원하는 버전)
```java
public class Args {
    private String schema;
    private String[] args;
    private boolean valid;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, Boolean> booleanArgs = new HashMap<Character, Boolean>();
    private int numberOfArguments = 0;

    public Args(String schema, String[] args) {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    public boolean isValid() {
        return valid;
    }

    private boolean parse() {
        if (schema.length() == 0 && args.length == 0) {
            return true;
        }
        parseSchema();
        parseArguments();
        return unexpectedArguments.size() == 0;
    }

    private boolean parseSchema() {
        for (String element : schema.split(",")) {
            parseSchemaElement(element);
        }
        return true;
    }

    private void parseSchemaElement(String element) {
        if (element.length() == 1) {
            parseBooleanSchemaElement(element);
        }
    }

    private void parseBooleanSchemaElement(String element) {
        char c = element.charAt(0);
        if (Character.isLetter(c)) {
            booleanArgs.put(c, false);
        }
    }

    private boolean parseArguments() {
        for (String arg : args) {
            parseArgument(arg);
        }
        return true;
    }

    private void parseArgument(String arg) {
        if (arg.startsWith("-")) {
            parseElements(arg);
        }
    }

    private void parseElements(String arg) {
        for (int i = 1; i < arg.length(); i++) {
            parseElement(arg.charAt(i));
        }
    }

    private void parseElement(char argChar) {
        if (isBoolean(argChar)) {
            numberOfArguments++;
            setBooleanArg(argChar, true);
        } else {
            unexpectedArguments.add(argChar);
        }
    }

    private void setBooleanArg(char argChar, boolean value) {
        booleanArgs.put(argChar, value);
    }

    private boolean isBoolean(char argChar) {
        return booleanArgs.containsKey(argChar);
    }

    public int cardinality() {
        return numberOfArguments;
    }

    public String usage() {
        if (schema.length() > 0) {
            return "-[" + schema + "]";
        } else {
            return "";
        }
    }

    public String errorMessage() {
        if (unexpectedArguments.size() > 0) {
            return unexpectedArgumentMessage();
        } else {
            return "";
        }
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");

        return message.toString();
    }

    public boolean getBoolean(char arg) {
        return booleanArgs.get(arg);
    }
}
```
위 코드가 많다고 생각할 수 있지만 나름대로 괜찮은 코드이다. 간결하고 단순하며 이해하기도 쉽다. 근데 뭔가 지저분해질 것 같은 기분이 든다. 
- 나중에 엉망으로 코드가 변할 요소는?

바로 위 코드에 String, Interger 라는 인수 유형 두 개만 추가했을 뿐인데, 코드가 엄청나게 지저분해지는 것을 알 수 있다. 위에서 Boolean 으로 처리된 메서드를 똑같이 String, Integer 인수 유형의 메서드도 추가 되어야 한다...

이는 유지와 보수가 적당히 수월 했던 코드가 버그와 결함이 숨어있을지도 모른다는 상당히 의심스러운 코드로 뒤바뀌어버린 것이다.

그래서 준비했다. String 인수 유형을 추가한 다음 코드이다.
### Args.java(Boolean 과 String, String 인수 유형 추가)
```java
public class Args {
    private String schema;
    private String[] args;
    private boolean valid = true;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, Boolean> booleanArgs = new HashMap<Character, Boolean>();
    private Map<Character, String> stringArgs = new HashMap<Character, String>();
    private Set<Character> argsFound = new HashSet<Character>();
    private int currentArgument;
    private char errorArgument = '\0';

    enum ErrorCode {
        OK, MISSING_STRING
    }

    private ErrorCode errorCode = ErrorCode.OK;

    public Args(String schema, String[] args) throws ParseException {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    private boolean parse() throws ParseException {
        if (schema.length() == 0 && args.length == 0) {
            return true;
        }
        parseSchema();
        parseArguments();
        return valid;
    }

    private boolean parseSchema() throws ParseException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                String trimmedElement = element.trim();
                parseSchemaElement(trimmedElement);
            }
        }
        return true;
    }

    private void parseSchemaElement(String element) throws ParseException {
        char elementId = element.charAt(0);
        String elementTail = element.subString(1);
        validateSchemaElementId(elementId);
        if (isBooleanSchemaElement(elementTail)) {
            parseBooleanSchemaElement(elementId);
        } else if (isStringSchemaElement(elementTail)) {
            parseStringSchemaElement(elementId);
        }
    }

    private void validateSchemaElementId(char elementId) throws ParseException {
        if (!Character.isLetter(elementId)) {
            throw new ParseException(
                "Bad character:" + elementId + "in Args format: " + schema, 0
            );
        }
    }

    private void parseStringSchemaElement(char elementId) {
        stringArgs.put(elementId, "");
    }

    private boolean isStringSchemaElement(String elementTail) {
        return elementTail.equals("*");
    }

    private boolean isBooleanSchemaElement(String elementTail) {
        return elementTail.length() == 0;
    }

    private void parseBooleanSchemaElement(char elementId) {
        booleanArgs.put(elementId, false);
    }

    private boolean parseArguments() {
        for (currentArgument = 0; currentArgument < args.length; currentArgument++) {
            String arg = args[currentArgument];
            parseArgument(arg);
        }
        return true;
    }

    private void parseArgument(String arg) {
        if (arg.startsWith("-")) {
            parseElements(arg);
        }
    }

    private void parseElements(String arg) {
        for (int i = 1; i < arg.length(); i++) {
            parseElement(arg.charAt(i));
        }
    }

    private void parseElement(char argChar) {
        if (setArgument(argChar)) {
            argsFound.add(argChar);
        } else {
            unexpectedArguments.add(argChar);
            valid = false;
        }
    }

    private boolean setArgument(char argChar) {
        boolean set = true;
        if (isBoolean(argChar)) {
            setBooleanArg(argChar, true);
        } else if (isString(argChar)) {
            setStringArg(argChar, "");
        } else {
            set = false;
        }

        return false;
    }

    private void setStringArg(char argChar, String s) {
        currentArgument++;
        try {
            stringArgs.put(argChar, args[currentArgument]);
        } catch (ArrayIndexOutOfBoundsException e) {
            valid = false;
            errorArgument = argChar;
            errorCode = ErrorCode.MISSING_STRING;
        }
    }

    private boolean isString(char argChar) {
        return stringArgs.containsKey(argChar);
    }

    private void setBooleanArg(char argChar, boolean value) {
        booleanArgs.put(argChar, value);
    }

    private boolean isBoolean(char argChar) {
        return booleanArgs.containsKey(argChar);
    }

    public int cardinality() {
        return argsFound.size();
    }

    public String usage() {
        if (schema.length() > 0) {
            return "-[" + schema + "]";
        } else {
            return "";
        }
    }

    public String errorMessage() throws Exception {
        if (unexpectedArguments.size() > 0) {
            return unexpectedArgumentMessage();
        } else {
            switch (errorCode) {
                case MISSING_STRING:
                    return String.format("Could not find string parameter for -%c.", errorArgument);
                case OK:
                    throw new Exception("TILT: Should not get here.");
            }
        }
        return "";
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");

        return message.toString();
    }

    public boolean getBoolean(char arg) {
        return falseIfNull(booleanArgs.get(arg));
    }

    private boolean falseIfNull(Boolean b) {
        return b == null ? false : b;
    }

    public String getString(char arg) {
        return blankIfNull(stringArgs.get(arg));
    }

    private String blankIfNull(String s) {
        return s == null ? "" : s;
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public boolean isValid() {
        return valid;
    }
}
```
String 인수 유형이 추가되었지만 아직까지는 읽을만하다. 하지만 새로운 인수 Integer 유형이 추가된다면 코드가 엄청 길어진다. 즉, 코드가 엉망이 되며 오류가 발생한다면 결함을 찾기 어려워진다.
### 그래서 멈췄다.
추가할 인수 유형이 적어도 두 개는 더 있었는데 코드가 더 나빠질것을 예상하고 멈추고 코드 구조를 유지보수하기 좋은 상태로 만들려면지금이 적기라 판단된 것이다.

기능을 추가하지 않고 리팩터링을 시작한다.

- 첫째, 인수 유형에 해당하는 HashMap을 성택하기 위해 스키마 요소의 구문을 분석한다.
- 둘째, 명령행 인수에서 인수 유형을 분석해 진짜 유형으로 변환한다.
- 셋째, getXXX 메서드를 구현해 호출자에게 진짜 유형을 반환한다.
### 점진적으로 개선하다
 프로그램을 망치는 가장 좋은 방법 중 하나는 개선이라는 이름 아래 구조를 크게 뒤집는 행위다. 어떤 프로그램은 그저 그런 '개선'에서 결코 회복하지 못한다. '개선'전과 똑같이 프로그램을 돌리기가 아주 어렵기 때문이다.

 그래서 테스트 주도 개발(TDD)이라는 기법을 사용할 수 있다.

 ## 5. Args.java 끝에 추가한 ArgumentMarshaler
 ```java
 private class ArgumentMarshaler {
    private boolean booleanValue = false;

    public void setBoolean(boolean value) {
        booleanValue = value;
    }

    public boolean getBoolean() { return booleanValue; }
}

private class BooleanArgumentMarshaler extends ArgumentMarshaler {}
private class StringArgumentMarshaler extends ArguemntMarshaler {}
private class IntegerArgumentMarshaler extends ArgumentMarshaler {}
 ```

Boolean 인수를 저장하는 HashMap 에서 Boolean 인수 유형을 ArgumentMarshaler 유형으로 바꾼다.
```java
private Map<Character, ArgumentMarshaler> booleanArgs = 
    new HashMap<Character, ArgumentMarshaler>();
```
이렇게 바뀌면 코드가 일부 깨지므로 코드를 고쳐야 한다.
```java
private void parseBooleanSchemaElement(char elementId) {
    booleanArgs.put(elementId, new BooleanArgumentMarshaler());
}
```
```java
private void setBooleanArgs(char argChar, boolean value) {
    booleanArgs.get(argChar).setBoolean(value);
}
```
```java
public boolean getBoolean(char arg) {
    return falseIfNull(booleanArgs.get(arg).getBoolean());
}
```
새 인수 유형을 추가하면서 parse, get set 부분 메서드를 변경해야 한다. 사소한 변경이었지만 위에 코드는 몇몇 테스트 케이스가 실패하기 시작한다. getBoolean 함수를 살펴볼 수 있다.
```java
falseIfNull()
```
falseIfNull 메서드를 주목해야 한다. 우리는 HashMap 에서 Boolean 인수 유형을 ArgumentMarshaler 유형으로 바꾸었다. 이는 null 을 반환하게 되며, NullPointerException 을 던진다.

고치는 방법은 어렵지 않다. null 점검 위치만 변경해주면 된다.
```java
public boolean getBoolean(char arg) {
    return booleanArgs.get(arg).getBoolean();
}
```
기차 충돌 코드를 피하기 위해서 변수를 사용하는 것이 좋을 것 같은 생각이 든다. 그리고 긴 변수명은 싫고 유형 이름과 중복이 심했고 함수가 길어졌으니 짧은 변수명을 생각해야 한다.
```java
public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = booleanArgs.get(arg);
    return am.getBoolean();
}
```
그 다음 null을 점검하면 된다.
```java
public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = booleanArgs.get(arg);
    return am != null && am.getBoolean();
}
```
## 6. String 인수
String 인수를 추가하는 과정은 boolean 인수와 매우 유사하다. HashMap을 변경한 후 parse, set, get 함수를 고치면 된다.

### Args.java 끝에 추가한 ArgumentMarshaler + String 인수
```java
private Map<Character, ArgumentMarshaler> stringArgs = 
    new HashMap<Character, ArgumentMarshaler>();
```
```java
private void parseStringSchemaElement(char elementId) {
    stringArgs.put(elementId, new StringArgumentMarshaler());
}
```
```java
private void setStringArg(char argChar) throws ArgsException {
    currentArgument++;
    try {
        stringArgs.get(argChar).setString(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
        valid = false;
        errorArgumentId = argChar;
        errorCode = ErrorCode.MISSING_STRING;
        throw new ArgsException();
    }
}
```
```java
public String getString(char arg) {
    Args.ArgumentMarshaler am = stringArgs.get(arg);
    return am == null ? "" : am.getString();
}
```
```java
private class ArgumentMarshaler {
    private String stringValue;

    public void setString(String s) {
        stringValue = s;
    }

    public String getString() {
        return stringValue == null ? "" : stringValue;
    }
}
```
의도를 눈치챘는가? 

일단 각 인수 유형을 처리하는 코드를 모두 ArgumentMarshaler 클래스에 넣고 나서 ArgumentMarshaler 파생 클래스를 만들어 코드를 분리할 작정인 것이다. 그러면 프로그램 구조를 조금씩 변경하는 동안에도 시스템의 정상 동작을 유지하기 쉬워지기 때문이다.

### Args.java 끝에 추가한 ArgumentMarshaler + Integer 인수
```java
private Map<Character, ArgumentMarshaler> intArgs =
    new HashMap<Character, ArgumentMarshaler>();
```
```java
private void parseIntegerSchemaElement(char elementId) {
    intArgs.put(elementId, new IntegerArgumentMarshaler());
}
```
```java
private void setIntArg(char argChar) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
        parameter = args[currentArgument];
        intArgs.get(argChar).setInteger(Integer.parseInt(parameter));
    } catch (ArrayIndexOutOfBoundsException e) {
        valid = false;
        errorArgumentId = argChar;
        errodCode = ErrorCode.MISSING_INTEGER;
        throw new ArgsException();
    } catch (NumberFormatException e) {
        valid = false;
        errorArgumentId = argChar;
        errorParameter = parameter;
        errorCode = ErrorCode.INALID_INTEGER;
        throw new ArgsException();
    }
}
```
```java
public int getInt(char arg) {
    Args.ArgumentMarshaler am = intArgs.get(arg);
    return am == null ? 0 : am.getInteger();
}
```
```java
private class ArgumentMarshaler {
    private int integerValue;

    public void setInteger(int i) {
        integerValue = i;
    }

    public int getInteger() {
        return integerValue;
    }
}
```
이제 boolean, string, integer 의 인수 유형을 만들어 ArgumentMarshaler 로 옮겼으니 파생 클래스를 만들어 기능을 분산할 차례이다.
- 뭔 소리야?

```java
private class BooleanArgumentMarshaler extends ArgumentMarshaler {}
private class StringArgumentMarshaler extends ArguemntMarshaler {}
private class IntegerArgumentMarshaler extends ArgumentMarshaler {}
```
위에서 ArgumentMarshaler 파생 클래스인 BooleanArgumentMarshaler, StringArgumentMarshaler, IntegerArgumentMarshaler 의 클래스로 각 함수를 옮기고 올바로 호출되는 지 확인하는 것이다.

## 7. 추상 클래스, abstract class ArgumentMarshaler
우선 ArgumentMarshaler 클래스에 추상 메서드 set을 만든다.
### abstract class ArgumentMarshaler + 추상 메서드 set + Boolean 인수
```java
private abstract class ArgumentMarshaler {
    protected boolean booleanValue = false;
    private String stringValue;
    private int integerValue;

    public void setBoolean(boolean value) {
        booleanValue = value;
    }

    public boolean getBoolean() {
        return booleanValue;
    }

    public void setString(String s) {
        stringValue = s;
    }

    public String getString() {
         return stringValue == null ? "" :  stringValue;
    }

    public void setInteger(int i) {
        integerValue = i;
    }

    public int getInteger() {
        return integerValue;
    }

    public abstract void set(String s);
}
```
다음으로 BooleanArgumentMarshaler 클래스에 set 메서드를 구현(오버라이딩) 한다.
```java
private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    public void set(String s) {
        booleanValue = true
    }
}
```
setBoolean 호출을 set 호출로 바꾼다.
```java
private void setBooleanArg(char argChar, boolean value) {
    booleanArgs.get(argChar).set("true");
}
```
set 기능을 BooleanArgumentMarshaler로 옮겼으니 ArgumentMarshaler에서 setBoolean 메서드를 제거했다.

다음은 get 메서드를 BooleanArgumentMarshaler로 옮겼다. get 함수는 언제나 옮기기 어렵다. 그 이유는 반환 객체 유형이 Object이여야 하기 때문이다.
### abstract class ArgumentMarshaler + get 메서드 + Boolean 인수
```java
private abstract class ArgumentMarshaler {
    public Object get() {
        return null;
    }
}
```
컴파일은 되었으나 테스트는 실패한다. 

테스트를 통과하기 위해 ArgumentMarshaler에서 get을 추상 메서드로 만든 후 BooleanArgumentMarshaler에다 get을 구현했다.
```java
private abstract class ArgumentMarshaler {
    protected boolean booleanValue = false;

    public abstract Object get();
}
```
```java
private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    public Object get() {
        return booleanValue;
    }
}
```
코드는 모든 테스틑 통과하였다! get과 set을 BooleanArgumentMarshaler로 모두 옮기는데 성공한 것이다. ArgumentMarshaler에서 사용하지 않는 getBoolean 함수를 제거한다.

### abstract class ArgumentMarshaler + get, set 메서드 + String 인수
String 인수 유형도 동일한 방식으로 변경하였다. set과 get을 옮긴 후 사용하지 않는 함수를 제거하고 변수를 옮겼다.
```java
private void setStringArgs(char argChar) throws ArgsException {
    currentArgument++;
    try {
        stringArgs.get(argChar).set(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
        valid = false;
        errorArgumentId = argChar;
        errodCode = ErrorCode.MISSING_STRING;
        throw new ArgsException();
    }
}
```
```java
public String getString(char arg) {
    Args.ArgumentMarshaler am = stringArgs.get(arg);
    return am == null ? "" : (String) am.get();
}
```
```java
private abstract class ArgumentMarshaler {
    private int integerValue;

    public void setInteger(int i) {
        integerValue = i;
    }

    public int getInteger() {
        return integerValue;
    }

    public abstract void set(String s);
    public abstract Object get();
}
```
```java
private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    private boolean booleanValue = false;

    public void set(String s) {
        booleanValue = true;
    }

    public Object get() {
        return booleanValue;
    }
}
```
```java
private class StringArgumentMarshaler extends ArgumentMarshaler {
    private String stringValue = "";

    public void set(String s) {
        stringValue = s;
    }

    public Object get() {
        return stringValue;
    }
}
```
위 코드에서 ArgumentMarshaler 클래스에서 boolean, string 인수 유형의 get, set 함수가 없어진 것을 볼 수 있고, BooleanArgumentMarshaler과 StringArgumentMarshaler 클래스에 get, set 함수를 추가한 것을 알 수 있다.

마지막으로 intgeger 인수 유형도 같은 과정을 반복하면 된다.
### abstract class ArgumentMarshaler + get, set 메서드 + Integer 인수
```java
private boolean isIntArg(char argChar) { 
    return intArgs.containsKey(argChar);
}
```
```java
private void setIntArg(char argChar) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
        parameter = args[currentArgument];
        intArgs.get(argChar).set(parameter);
    } catch (ArrayIndexOutOfBoundsException e) {
        valid = false;
        errorArgumentId = argChar;
        errorCode = ErrorCode.MISSING_INTEGER;
        throw new ArgsException();
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        errorParameter = parameter;
        errorCode = ErrorCode.INVALID_INTEGER;
        throw e;
    }
}
```
```java
private void setBooleanArg(char argChar) {
    try {
        booleanArgs.get(argChar).set("true");
    } catch (ArgsException e) {}
}
```
```java
public int getInt(char arg) {
    Args.ArgumentMarshaler am = intArgs.get(arg);
    return am == null ? 0 : (Integer) am.get();
}
```
```java
private abstract class ArgumentMarshaler {
    public abstract void set(String s) throws ArgsException;
    public abstract Object get();
}
```
```java
private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    private int intValue = 0;

    public void set(String s) throws ArgsException {
        try {
            intValue = Integer.parseInt(s);
        } catch (NumberFormatException e) {
            throw new ArgsException();
        }
    }

    public Object get() {
        return intValue;
    }
}
```
여기서 주목해야 할 부분 ArgumentMarshaler 클래스를 보면 알 수 있다. 많이 간소화 된 것을 알 수 있다.

다음으로 Args 클래스에 처음에 나오는 (인수 유형마다 따로 만든) 맵 세 개를 없앤다. 하지만 그냥 없애면 에러가 난다. 그 대신 ArgumentMarshaler로 맵을 만들어 원래 맵을 교체하고 관련 메서드를 변경했다.

## 8. Args.java (첫 번째 리팩터링 과정)
- Map 변수 변경하기
```java
public class Args {
    private Map<Character, ArgumentMarshaler> booleanArgs = 
        new HashMap<Character, ArgumentMarshaler>();
    private Map<Character, ArgumentMarshaler> stringArgs = 
        new HashMap<Character, ArgumentMarshaler>();
    private Map<Character, ArgumentMarshaler> intArgs = 
        new HashMap<Character, ArgumentMarshaler>();
}
```
```java
public class Args {
    private Map<Character, ArgumentMarshaler> marshalers =
        new HashMap<Charcter, ArgumentMarshaler>();
}
```
- 각 인수유형마다 값 넣어주는 함수 변경
```java
public class Args {
    private void parseBooleanSchemaElement(char elementId) {
        booleanArgs.put(elementId, m);
    }
    private void parseIntegerSchemaElement(char elementId) {
        intArgs.put(elementId, m);
    }
    private void parseStringSchemaElement(char elementId) {
        stringArgs.put(elementId, m);
    }
}
```
```java
public class Args {
    private void parseBooleanSchemaElement(char elementId) {
        ArgumentMarshaler m = new BooleanArgumentMarshaler();
        marshalers.put(elementId, m);
    }
    private void parseIntegerSchemaElement(char elementId) {
        ArgumentMarshaler m = new IntegerArgumentMarshaler();
        marshalers.put(elementId, m);
    }
    private void parseStringSchemaElement(char elementId) {
        ArgumentMarshaler m = new StringArgumentMarshaler();
        marshalers.put(elementId, m);
    }
}
```
- isBooleanArg 변경
```java
private boolean isBooleanArgs(char argChar) {
    return booleanArgs.containsKey(argChar);
}
```
```java
private boolean isBooleanArg(char argChar) {
    ArgumentMarshaler m = marshalers.get(argChar);
    return m instanceOf BooleanArgumentMarshaler;
}
```
- isIntArg, isStringArg 도 변경
```java
private boolean isIntArg(char argChar) {
    return intArgs.containsKey(argChar);
}
private boolean isStringArg(char argChar) {
    return stringArgs.containsKey(argChar);
}
```
```java
private boolean isIntArg(char argChar) {
    ArgumentMarshaler m = marshalers.get(argChar);
    return m instanceOf IntegerArgumentMarshaler;
}
private boolean isStringArg(char argChar) {
    ArgumentMarshaler m = marshalers.get(argChar);
    return m instanceOf StringArgumentMarshaler;
}
```

중복되는 `marshalers.get` 함수...

- marshalers.get 함수를 제거하자
```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (isBooleanArg(m)) {
        setBooleanArg(argChar);
    } else if (isStringArg(m)) {
        setStringArg(argChar);
    } else if (isIntArg(m)) {
        setIntArg(argChar);
    } else {
        return false;
    }

    return true;
}

private boolean isIntArg(ArgumentMarshaler m) {
    return m instanceOf IntegerArgumentMarshaler;
}

private boolean isStringArg(ArgumentMarshaler m) {
    return m instanceOf StringArgumentMarshaler;
}

private boolean isBooleanArgs(ArgumentMarshaler m) {
    return m instanceOf BooleanArgumentMarshaler;
}
```

근데 isXXXArgs 함수가 필요할까? 굳이 필요 없을 것 같다. 그러므로 인라임 코드로 만들어버리자.
```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m instanceOf BooleanArgumentMarshaler) {
        setBooleanArg(argChar);
    } else if (m instanceOf StringArgumentMarshaler) {
        setStringArg(argChar);
    } else if (m instanceOf IntegerArgumentMarshaler) {
        setIntArg(argChar);
    } else {
        return false;
    }

    return true;
}
```
다음으로 setXXArg 함수를 변경해보자. 기존 HashMap 을 marhshalers HashMap으로 교체하는 것을 진행한다.
- setBooleanArg 
```java
private void setBooleanArg(ArgumentMarshaler m) {
    try {
        // 이전 코드 : booleanArgs.get(argChar).set("true");
        m.set("true") ;
    } catch (ArgsException e) {
    }
}
```
String과 Integer 인수 유형도 똑같이 진행한다. 추가적으로 일부 흉한 예외 관리 코드를 setArgument 함수 넣을 수 있다.
- setStringArg, setIntArg
```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    try {
        if (m instanceOf BooleanArgumentMarshaler) {
            setBooleanArg(m);
        } else if (m instanceOf StringArgumentMarshaler) {
            setStringArg(m);
        } else if (m instanceOf IntegerArgumentMarshaler) {
            setIntArg(m);
        } else {
            return false;
        }
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        throw e;
    }
    return true;
}
```
```java
private void setStringArg(ArgumentMarshaler m) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
        parameter = args[currentArgument];
        m.set(parameter);
    } catch (ArrayIndexOutOfBoundsException e) {
        errorCode = ErrorCode.MISSING_INTEGER;
        throw new ArgsException();
    } catch (ArgsException e) {
        errorParameter = parameter;
        errorCode = ErrorCode.INVALID_INTEGER;
        throw e;
    }
}

private void setIntArg(ArgumentMarshaler m) throws ArgsException {
    currentArgument++;
    try {
        m.set(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
        errorCode = ErrorCode.MISSING_STRING;
        throw new ArgsException();
    }
}
```
이제 원래 맵 세개를 제거해도 괜찮은 시점이다. 

우선 getBoolean 함수를 변경하자.
- getBoolean
```java
public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = booleanArgs.get(arg);
    return am != null && (Boolean) am.get();
}
```
```java
public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = marshalers.get(arg);
    boolean b = false;
    try {
        b = am != null && (Boolean) am.get();
    } catch (ClassCastException e) {
        b = false;
    }
    return b;
}
```

자 이제 boolean 맵을 사용하는 코드를 제거할 수 있다. 즉, 아래 변수가 사용되었던 코드를 삭제해도 된다.
```java
booleanArgs
```

String과 Integer 인수 유형도 boolean과 마찬가지로 변경하고 이전 맵을 제거하면 된다. 그 전에 parseXXXSchemaElement 함수의 객체 할당을 하지말고 일회성 클래스 인스턴스로 사용하여 진행하자.
- parseXXXSchemaElement
```java
private void parseBooleanSchemaElement(char elementId) {
    // 이전 코드 
    // ArgumentMarshaler m = new BooleanArgumentMarshaler();
    // marshaelrs.put(elementId, m);
    marshalers.put(elementId, new BooleanArgumentMarshaler());
}

private void parseIntegerSchemaElement(char elementId) {
    marshalers.put(elementId, new IntegerArgumentMarshaler());
}

private void parseStringSchemaElement(char elementId) {
    marshalers.put(elmentId, new StringArgumentMarshaler());
}
```
- getString, getInt
```java
public String getString(char arg) {
    Args.ArgumentMarshaler am = marshalers.get(arg);
    try {
        return am == null ? "" : (String) am.get();
    } catch (ClassCastException e) {
        return "";
    }
}

public int getInt(char arg) {
    Args.ArgumentMarshaler am = marshaelrs.get(arg);
    try {
        return am == null ? 0 : (Integer) am.get();
    } catch (Exception e) {
        return 0;
    }
}
```
String, Integer 인수 유형 맵 변수 사용은 제거해도 된다.
```java
stringArgs
intArgs
```

그 다음 parseXXXSchemaElement 함수가 parseSchemaElement에 사용 될때, 함수로 사용되었는데, 이 부분도 인라인 코드로 바꾸자.
```java
private void parseSchemaElement(String element) throws ParseException {
    if (isBooleanSchemaElement(elementTail)) {
        parseBooleanSchemaElement(elementId);
    }
}
```
```java
private void parseSchemaElement(String element) throws ParseException {
    if (isBooleanSchemaElement(elementTail)) {
        marshalers.put(elementId, new BooleanArgumentMarshaler());
    }
}
```
String 과 Integer 인수 유형도 마찬가지이므로 작성하지 않았다.

## 9. Args.java (첫 번째 리팩터링을 끝낸 버전)
```java
public class Args {
    private String schema;
    private String[] args;
    private boolean valid = true;
    private Set<Character> unexpectedArguments = new TreeSet<Character>();
    private Map<Character, ArgumentMarshaler> marshalers =
        new HashMap<Character, ArgumentMarshaler>();
    private Set<Character> argsFound = new HashSet<Character>();
    private int currentArgument;
    private char errorArgumentId = '\0';
    private String errorParameter = "TILT";
    private ErrorCode errorCode = ErrorCode.OK;

    private enum ErrorCode {
        OK, MISSING_STRING, MISSING_INTEGER, 
        INVALID_INTEGER,
        UNEXPECTED_ARGUMENT
    }

    public Args(String schema, String[] args) throws ParseException {
        this.schema = schema;
        this.args = args;
        valid = parse();
    }

    private boolean parse() throws ParseException {
        if (schema.length() == 0 && args.length == 0) {
            return true;
        }
        parseSchema();
        try {
            parseArguments();
        } catch (ArgsException e) {
        }
        return valid;
    }

    private boolean parseSchema() throws ParseException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                String trimmedElement = element.trim();
                parseSchemaElement(trimmedElement);
            }
        }
        return true;
    }

    private void parseSchemaElement(String element) throws ParseException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (isBooleanSchemaElement(elementTail)) {
            marshalers.put(elementId, new BooleanArgumentMarshaler());
        } else if (isStringSchemaElement(elementTail)) {
            marshalers.put(elementId, new StringArgumentMarshaler());
        } else if (isIntgerSchemaElement(elementTail)) {
            marshalers.put(elementId, new IntegerArgumentMarshaler());
        } else {
            throw new ParseException(String.format(
                "Argument: %c has invalid format: %s.", elementId, elementTail
            ), 0);
        }
    }

    private void validateSchemaElementId(char elementId) throws ParseException {
        if (!Character.isLetter(elementId)) {
            throw new ParseException(
                "Bad character:" + elementId + "in Args format: "  + schema, 0
            );
        }
    }

    private boolean isStringSchemaElement(String elementTail) {
        return elementTail.equals("*");
    }

    private boolean isBooleanSchemaElement(String elementTail) {
        return elementTail.length() == 0;
    }

    private boolean isIntegerSchemaElement(String elementTail) {
        return elementTail.equals("#");
    }

    private boolean parseArguments() throws ArgsException {
        for (currentArgument = 0; currentArgument < args.length; currentArgument++) {
            String arg = args[currentArgument];
            parseArgument(arg);
        }
        return true;
    }

    private void parseArgument(String arg) throws ArgsException {
        if (arg.startsWith("-")) {
            parseElements(arg);
        }
    }

    private void parseElements(String arg) throws ArgsException {
        for (int i = 1; i < arg.length(); i++) {
            parseElement(arg.charAt(i));
        }
    }

    private void parseElement(char argChar) throws ArgsException {
        if (setArgument(argChar)) {
            argsFound.add(argChar);
        } else {
            unexpectedArguments.add(argChar);
            errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
            valid = false;
        }
    }

    private boolean setArgument(char argChar) throws ArgsException {
        ArguemntMarshaler m = marshalers.get(argChar);
        try {
            if (m instanceOf BooleanArgumentMarshaler) {
                setBooleanArg(m);
            } else if (m instanceOf StringArgumentMarshaler) {
                setStringArg(m);
            } else if (m instanceOf IntegerArgumentMarshaler) {
                setIntArg(m);
            } else {
                return false;
            }
        } catch (ArgsException e) {
            valid = false;
            errorArgumentId = argChar;
            throw e;
        }
        return true;
    }

    private void setIntArg(ArgumentMarshaler m) throws ArgsException {
        currentArgument++;
        String parameter = null;
        try {
            parameter = args[currentArgument];
            m.set(parameter);
        } catch (ArrayIndexOutOfBoundsException e) {
            errorCode = ErrorCode.MISSING_INTEGER;
            throw new ArgsException();
        } catch (ArgsException e) {
            errorParameter = parameter;
            errorCode = ErrroCode.INVALID_INTEGER;
            throw e;
        }
    }

    private void setStringArg(ArgumentMarshaler m) throws ArgsException {
        currentArgument++;
        try {
            m.set(args[currentArgument]);
        } catch (ArrayIndexOutOfBoundsException e) {
            errorCode = ErrorCode.MISSING_STRING;
            throw new ArgsException();
        }
    }

    private void setBooleanArg(ArgumentMarshaler m) {
        try {
            m.set("true");
        } catch (ArgsException e) {
        }
    }

    public int cardinality() {
        return argsFound.size();
    }

    public String usage() {
        if (schema.length() > 0) {
            return "-[" + schema + "]";
        } else {
            return "";
        }
    }

    public String errorMessage() throws Exception {
        switch (errorCode) {
            case OK:
                return new Exception("TILT: Should not get here.");
            case UNEXPECTED_ARGUMENT:
                return unexpectedArgumentMessage();
            case MISSING_STRING:
                return String.format("Could not find string parameter for -%c.", errorArgumentId);
            case INVALID_INTEGER:
                return String.format("Argument -%c expects an integer but was '%s'.", errorArgumentId, errorParameter);
            case MISSING_INTEGER:
                return String.format("Could not find integer parameter for -%c.", errorArgumentId);
        } 
        return "";
    }

    private String unexpectedArgumentMessage() {
        StringBuffer message = new StringBuffer("Argument(s) -");
        for (char c : unexpectedArguments) {
            message.append(c);
        }
        message.append(" unexpected.");

        return message.toString();
    }

    public boolean getBoolean(char arg) {
        Args.ArgumentMarshaler am = marshalers.get(arg);
        boolean b = false;
        try {
            b = am != null && (Boolean) am.get();
        } catch (ClassCastException e) {
            b = false;
        }
        return b;
    }

    public String getString(char arg) {
        Args.ArgumentMarshaler am = marshalers.get(arg);
        try {
            return am == null ? "" : (String) am.get();
        } catch (ClassCastException e) {
            return "";
        }
    }

    public int getInt(char arg) {
        Args.ArgumentMarshaler am = marshalers.get(arg);
        try {
            return am == null ? 0 : (Integer) am.get();
        } catch (Exception e) { 
            return 0;
        }
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }

    public boolean isValid() {
        return valid;
    }

    private class ArgsException extends Exception {
    }

    private abstract class ArgumentMarshaler {
        public abstract void set(String s) throws ArgsException;
        public abstract Object get();
    }

    private class BooleanArgumentMarshaler extends ArgumentMarshaler {
        private boolean booleanValue = false;

        public void set(String s) {
            booleanValue = true;
        }

        public Object get() {
            return booleanValue;
        }
    }

    private class StringArgumentMarshaler extends ArgumentMarshaler {
        private String stringValue = "";

        public void set(String s) {
            stringValue = s;
        }

        public Object get() {
            return stringValue;
        }
    }

    private class IntegerArgumentMarshaler extends ArgumentMarshaler {
        private int intValue = 0;

        public void set(String s) throws ArgsException {
            try {
                intValue = Integer.parseInt(s);
            } catch (NumberFormatException e) {
                throw new ArgsException();
            }
        }

        public Object get() {
            return intValue;
        }
    }
}
```

그 전에 작성한 Args.java 1차 초안을 보려면 [Args.java 1차 초안](#4-args--1차-초안 )링크로 넘어가자. 그리고 Args.java 리팩토링 과정을 살펴보려면 [Args.java 리팩토링 과정](#8-argsjava-첫-번째-리팩터링-과정) 링크로 확인하자.

- 첫 번째 리팩토링은 어떤가?

다소 실망적인 코드다. 구조만 조금 나아졌다. 첫머리에 나오는 변수는 아직도 남아있으며, setArgument에는 유형을 일일이 확인하는 보기 싫은 코드도 남아있다. 게다가 모든 set함수는 정말로 흉하다. 오류 처리 코드 또한 마찬가지이다. 


### setArgument 유형 체크 제거 과정
setArgument 에서 유형을 일일이 확인하는 보기 싫은 코드를 없애고 싶었고, setArgument에서 ArgumentMarshaler.set만 호출하면 충분하게 만들고 싶었다.
```java
private boolean setArgument(char argChar) throws ArgumentException {
    //...
    if (m instanceOf BooleanArgumentMarshaler) {}
    else if (m instanceOf StringArgumentMarshaler) {}
    else if (m instanceOf IntegerArgumentMarshaler)
}
```
해결책은 간단하다. args 배열을 list로 변환한 후 Iterator를 set함수로 전달하면 된다.
```java
public class Args {
    // ...
    private String[] args;
}
```
```java
public class Args {
    // ...
    private Iterator<String> currentArgument;
    private List<String> argsList;
}
```
`args` 배열 객체를 없앴다. 다음으로 변환하는 과정을 처리해보자.
```java
public Args(String schema, String[] args) throws ParseException {
    this.schema = schema;
    argsList = Arrays.asList(args);
    valid = parse();
}
```
`args` 를 `List` 로 변환한다.
```java
private boolean parse() throws ParseException {
    if (schema.length() == 0 && argsList.size() == 0) {
        return true;
    }
    parseSchema();
    try {
        parseArguments();
    } catch (ArgsException e) {
    }
    return valid;
}
```
`argsList.size() == 0`  조건을 추가하였다.
```java
private boolean parseArguments() throws ArgsException {
    for (currentArgument = argsList.iterator(); currentArgument.hasNext();) {
        String arg = currentArgument.next();
        parseArgument(arg);
    }
    return true;
}
```
```java
private void setIntArg(ArgumentMarshaler m) throws ArgsException {
    String parameter = null;
    try {
        parameter = currentArgument.next();
        m.set(parameter);
    } catch (NoSuchElementException e) {
        errorCode = ErrorCode.MISSING_INTEGER;
        throw new ArgsException();
    } catch (ArgsException e) {
        errorParameter = parameter;
        errorCode = ErrorCode.INVALID_INTEGER;
        throw e;
    }
}

private void setStringArg(ArgumentMarshaler m) throws ArgsException {
    try {
        m.set(currentArgument.next());
    } catch (NoSuchElementException e) {
        errorCode = ErrorCode.MISSING_STRING;
        throw new ArgsException();
    }
}
```
이제 set 함수를 적절한 파생 클래스로 내려도 괜찮아졌다.

우선 setArgument 클래스를 변경하자.
```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null) {
        return false;
    }
    try {
        if (m instanceOf BooleanArgumentMarshaler) {
            setBooleanArg(m);
        } else if (m instanceOf StringArgumentMarshaler) {
            setStringArg(m);
        } else if (m instanceOf IntegerArgumentMarshaler) {
            setIntArg(m);
        }
        /**
         * m 의 null 체크가 있어서 없애주었다.
         * else { return false; }
        */
    } catch (ArgsException e) {
        valid = false;
        errorArgumentId = argChar;
        throw e;
    }
    return false;
}
```
이제 set 함수를 옮길 차례이다. setBooleanArg 함수 먼저 진행하자.
```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    //...
    try {
        if (m instanceOf BooleanArgumentMarshaler) {
            setBooleanArg(m, currentArgument);
        }
        //...
    }
}
```
```java
private void setBooleanArg(
    ArgumentMarshaler m, 
    Iterator<String> currentArgument
) throws ArgsException {
    m.set("true");
    /** 예외 처리 코드 삭제 가능! 
     * try {
     *   m.set("true");
     * } catch (ArgsException e) {}
     */
} 
```
리팩터링으로 예외 처리 코드를 빼버리고잇다. 큰 목표 하나를 이루기 위해 자잘한 단계를 수없이 거쳐야 한다.

setBooelanArg 함수에서는 Iterator 인자가 필요없다. 근데 왜 인수로 넘겼을까? setIntArg와 setStringArg에서 필요하기 때문이다. setBooleanArg, setIntArg, setStringArg 함수 모두를 ArgumentMarshaler의 추상 메서드로 호출하기 위해서이다.

먼저 ArgumentMarshaler 에 새로운 추상 메서드를 추가한다.
```java
private abstract class ArgumentMarshaler {
    public abstract void set(Iterator<String> currentArgument) throws ArgsException;
    public abstract void set(String s) throws ArgsException;
    public abstract Object get();
}
```
이렇게 추상 메서드를 추가하면 ArgumentMarshaler 파생 클래스는 컴파일이 실패한다. 그러므로 모두 set 메서드를 추가해주자.
```java
private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    //...

    public void set(Iterator<String> currentArgument) throws ArgsException {
        booleanValue = true;
    }
    
    public void set(String s) {
        // 해당 객체에 값을 할당하는 것은 없애도 된다.
        // booleanValue = true;
    }

    //...
}
```
```java
private class StringArgumentMarshaler extends ArgumentMarshaler {
    public void set(Iterator<String> currentArgument) throws ArgsException {
    }
}

```
```java
private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    public void set(Interator<String> currentArgument) throws ArgsException {
    }
}
```
이제 setArgument 함수에서 인수 유형을 확인하는 Boolean 유형에서 setBooleanArg 함수를 제거해도 안전한다.
```java
private boolean setArgument(char argChar) throws ArgsException {
    // ...
    try {
        if (m instanceOf BooleanArgumentMarshaler) {
            // setBooleanArg(m, currentArgument);
            m.set(currentArgument);
        }
        //...
    }
    return true;
}
```
이제 String과 Integer 인수도 똑같이 진행하면 된다.
```java
private boolean setArgument(char argChar) throws ArgsException {
    //...
    try {
        //...
        else if (m instanceOf StringArgumentMarshaler) {
            // setStringArg(m);
            m.set(currentArgument);
        }
        else if (m instanceOf IntegerArgumentMarshaler) {
            // setIntArg(m);
            m.set(currentArgument);
        }
        //...
    }
    return true;
}
```
```java
private class StringArgumentMarshaler extends ArgumentMarshaler {
    public void set(Iterator<String> currentArgument) throws ArgsException {
        try {
            stringValue = currentArgument.next();
        } catch (NoSuchElementException e) {
            errorCode = ErrorCode.MISSING_STRING;
            throw new ArgsException();
        }
    }
}
```
```java
private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    public void set(Iterator<String> currentArgument) throws ArgsException {
        String parameter = null;
        try {
            parameter = currentArgument.next();
            set(parameter);
        } catch (NoSuchElementException e) {
            errorCode = ErrorCode.MISSING_INTEGER;
            throw new ArgsException();
        } catch (ArgsException e) {
            errorParameter = parameter;
            errorCode = ErrorCode.INVALID_INTEGER;
            throw e;
        }
    }
}
```

### setArgument 유형 체크 제거 코드
이제 마지막이다! 

setArgument 함수에서 인수 유형을 일일이 확인하던 코드를 제거해도 괜찮다.
```java
private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null) {
        return false;
    }
    try {
        m.set(currentArgument);
        return true;
    } catch (ArgsException e) {
        valid = false;
        errroArgumentId = argChar;
        throw e;
    }
}
```
### IntegerArgumentMarshaler 몇 가지 허술한 코드 고치기
```java
private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    private int intValue = 0

    public void set(Iterator<String> currentArgument) throws ArgsException {
        String parameter = null;
        try {
            parameter = currentArgument.next();
            intValue = Integer.parseInt(parameter);
        } catch (NoSuchElementException e) {
            errorCode = ErrorCode.MISSING_INTEGER;
            throw new ArgsException();
        } catch (NumberFormatException e) {
            errorParameter = parameter;
            errorCode = ErrorCode.INVALID_INTEGER;
            throw new ArgsException();
        }
    }

    public Object get() {
        return intValue;
    }
}
```

또한, ArgumentMarshaler를 인터페이스로 변환한다.
```java
private interface ArgumentMarshaler {
    void set(Iterator<String> currentArgument) throws ArgsException;
    Object get();
}
```

## 10. 새로운 인수 유형 추가 - Double
자 이제 우리 구조에 새로운 인수 유형을 추가하기 얼마나 쉬운지 살펴보자. 우선 시스템이 double 인수 유형을 제대로 받아들이는지 확인할 테스트 케이스부터 추가한다.
```java
public void testSimpleDoublePresent() throws Exception {
    Args args = new Args("x##", new String[] {"-x","42.3"});
    assertTrue(args.isValid());
    assertEquals(1, args.cardinality());
    assertTrue(args.has('x'));
    assertEquals(42.3, args.getDouble('x'), .001);
}
```
스키마 구문분석 코드를 정리하고 ## 감지 코드를 추가한다. 여기서 ##는 double 인수 유형을 뜻한다.
```java
private void praseSchemaElement(String element) throws ParseExceptoin {
    char elementId = element.charAt(0);
    String elementTail = element.substring(1);
    validateSchemaElementId(elementId);
    if (elementTail.length() == 0) {
        marshalers.put(elementId, new BooleanArgumentMarshaler());
    } else if (elementTail.equals("*")) {
        marshalers.put(elementId, new StringArgumentMarshaler());
    } else if (elementTail.equals("#")) {
        marshalers.put(elementId, new IntegerArgumentMarshaler());
    } else if (elementTail.eqauls("##")) {
        marshalers.put(elementId, new DoubleArgumentMarshaler());
    } else {
        throw new ParseException(String.format(
            "Argument: %c has invalid format: %s.", elementId, elementTail
        ), 0);
    }
}
```

다음으로 DoubleArgumentMarshaler 클래스를 작성한다.
### DoubleArgumentMarshaler 클래스
```java
private class DoubleArgumentMarshaler implements ArgumentMarshaler {
    private double doubleValue = 0;

    public void set(Iterator<String> currentArgument) throws ArgsException {
        String parameter = null;
        try {
            parameter = currentArgument.next();
            doubleValue = Double.parseDouble(parameter);
        } catch (NoSuchElementException e) {
            errorCode = ErrorCode.MISSING_DOUBLE;
            throw new ArgsException();
        } catch (NumberFormatException e) {
            errorParameter = parameter;
            errorCode = ErrorCode.INVALID_DOUBLE;
            throw new ArgsException();
        }
    }

    public Object get() {
        return doubleValue;
    }
}
```

새로운 ErrorCode
```java
private enum ErrorCode {
    OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER,
    UNEXPECTED_ARGUMENT, MISSING_DOUBLE, INVALID_DOUBLE
}
```

getDouble 함수도 필요하다.
```java
public double getDouble(char arg) {
    Args.ArgumentMarshaler am = marshalers.get(arg);
    try {
        return am == null ? 0 : (Double) am.get();
    } catch (Exception e) {
        return 0.0;
    }
}
```

테스트 코드를 작성해야 오류 처리 코드가 잘 도는 지 확인해야 한다. 구문분석이 불가능한 문자열을 ## 인수에 전달해 오류 처리 코드 동작을 확인한다.
```java
public void testInvalidDouble() throws Exception {
    Args args = new Args("x##", new String[] {"-x","Forty two"});
    assertFalse(args.isValid());
    assertEquals(0, args.cardinality());
    assertFalse(args.has('x'));
    assertEquals(0, args.getInt('x'));
    assertEquals("Argument -x expects a double but was 'Forty two'.", 
        args.errorMessage());
}

public String errorMessage() throws Exception {
    switch (errorCode) {
        case OK:
            throw new Exception("TILT: Should not get here.");
        // ...
        case INVALID_DOUBLE:
            return String.format("Argument -%c expectes a double but was "%s".",
                errorArgumentId, errorParameter);
        case MISSING_DOUBLE:
            return String.format("Could not find double parameter for -%c.",
                errorArgumentId);
    }
    return "";
}
```

코드는 테스트를 통과한다. 다음 테스트 케이스는 double 인수를 빠뜨린 경우다.
```java
public void testMissingDouble() throws Exception {
    Args args = new Args("x##", new String[]{"-x"});
    assertFalse(args.isValid());
    assertEquals(0, args.cardinality());
    assertFalse(args.has("x"));
    assertEquals(0.0, args.getDouble("x"), 0.01);
    assertEquals("Could not find double parameter for -x.", args.errorMessage());
}
```

코드는 테스트를 통과한다. 철저함을 가하고자 테스트 케이스를 작성했을 뿐이다!

예외 코드는 아주 흉할뿐더러 사실상 Args 클래스에 속하지도 않는다. 게다가 ParseException 을 던지지만 ParseException은 Args 클래스에 속하지 않는다.

그러므로 모든 예외를 하나로 모아 ArgsException 클래스를 만든 후 독자 모듈로 옮긴다.
## 11. ArgsException 클래스
```java
public class ArgsException extends Exception {
    private char errorArguemntId = "\0";
    private String errorParameter = "TILT";
    private ErrorCode errorCode = ErrorCode.OK;

    public ArgsException() {}

    public ArgsException(String message) { super(message); }

    public enum ErrorCode {
        OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER,
        UNEXPECTED_ARGUMENT, MISSING_DOUBLE, INVALID_DOUBLE
    }
}

```
```JAVA
public class Args {
    //...
    private ArgsException.ErrorCode errorCode = ArgsException.ErrorCode.OK;

    public Args(String schema, String[] args) throws ArgsException {
        this.schema = schema;
        //...
    }

    private boolean parse() throws ArgsException {
        //...
        parseSchema();
        try {
            parseArguments();
        } catch (ArgsException e) {
        }
        return valid;
    }

    private boolean parseSchema() throws ArgsException {
        //...
    }

    private void parseSchemaElement(String element) throws ArgsException {
        //...
        else {
            throw new ArgsException(
                String.format("Argument: %c has invalid format: %s.",
                    elementId, elementTail)
            );
        }
    }

    private void validateSchemaElementId(char elementId) throws ArgsException {
        if (!Character.isLetter(elementId)) {
            throw new ArgsExeption (
                "Bad character:" + elementId + "in Args format: " +schema
            );
        }
    }

    private void parseElement(char argChar) throws ArgsException {
        //...
        else {
            errorCode = ArgsException.ErrorCode.UNEXPECTED_ARGUMENT;
        }
    }

    private class StringArgumentMarshaler implements ArgumentMarshaler {
        //...

        public void set(Iterator<String> currentArgument) throws ArgsException {
            try {
                //...
            } catch (NoSuchElementException e) {
                errorCode = ArgsException.ErrorCode.MISSING_STRING;
            }
        }

        //...
    }

    private class IntegerArgumentMarshaler implements ArgumentMarshaler {
        //...

        public void set(Iterator<String> currentArgument) throws ArgsException {
            try {
                //...
            } catch (NoSuchElementException e) {
                //...
                throw new ArgsException();
            } catch (NumberFormatException e) {
                //...
                errorCode = ArgsException.ErrorCode.INVALID_INTEGER;
                throw new ArgsException();
            }
        }

        //...
    }

    private class DoubleArgumentMarshaler implements ArgumentMarshaler {
        //...

        public void set(Iterator<String> currentArgument) throws ArgsException {
            try {
                //...
            } catch (NoSuchElementException e) {
                errorCode = ArgsException.ErrorCode.MISSING_DOUBLE;
                //...
            } catch (NumberFormatException e) {
                //...
                errorCode = ArgsException.ErrorCode.INVALID_DOUBLE;
            }
        }

        //...
    }
}
```
멋지다.

이제 Args 클래스가 던지는 예외는 ArgsException 뿐이다. ArgsException을 독자적인 모듈로 만들면 Args 모듈에서 잡다한 오류 지원 코드를 옮겨올 수 있다. 

덕분에 Args 모듈이 깨끗해져 차후 확장도 쉬워진다.

이제는 Args 모듈에서 예외/오류 처리 코드를 완벽하게 분리했다.

30차례로 나눠 조금씩 코드를 바꾸었다. 물론 매 단계마다 코드는 테스트 통과이다.
## 12. ArgsTest.java
```java
public class ArgsTest extends TestCase {
    public void testCreateWithNoSchemaArguments() throws Exception {
        Args args = new Args("", new String[0]);
        assertEquals(0, args.cardinality());
    }

    public void testWithNoSchemaButWithOneArgument() throws Exception {
        try {
            new Args("", new String[]{"-x"});
            fail();
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
                e.getErrorCode());
            assertEquals('x', e.getErrorArgumentId());
        }
    }

    public void testWithNoSchemaButWithMultipleArguments() throws Exception {
        try {
            new Args("", new String[]{"-x", "-y"});
            fail();
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
                e.getErrorCode());
            assertEquals('x', e.getErrorArgumentId());
        }
    }

    public void testNonLetterSchema() throws Exception {
        try {
            new Args("*", new String[]{});
            fail("Args constructor should have thrown exception");
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,
                e.getErrorCode());
            assertEquals('*', e.getErrorArgumentId());
        }
    }

    public void testInvalidArgumentFormat() throws Exception {
        try {
            new Args("f~", new String[]{});
            fail("Args constructor should have throws exception");
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.INVALID_FORMAT, e.getErrorCode());
            assertEquals('f', e.getErrorArgumentId());
        }
    }

    public void testSimpleBooleanPresent() throws Exception {
        Args args = new Args("x", new String[]{"-x"});
        assertEquals(1, args.cardinality());
        assertEquals(true, args.getBoolean('x'));
    }

    public void testSimpleStringPresent() throws Exception {
        Args args = new Args("x*", new String[]{"-x", "param"});
        assertEquals(1, args.cardinality());
        assertTrue(args.has('x'));
        assertEquals("param", args.getString('x'));
    }

    public void testMissingStringArgument() throws Exception {
        try {
            new Args("x*", new String[]{"-x"});
            fail();
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.MISSING_STRING, e.getErrorCode());
            assertEquals('x', e.getErrorArgumentId());
        }
    }

    public void testSpacesInFormat() throws Exception {
        Args args = new Args("x, y", new String[]{"-xy"});
        assertEquals(2, args.cardinality());
        assertTrue(args.has('x'));
        assertTrue(args.has('y'));
    }

    public void testSimpleIntPresent() throws Exception {
        Args args = new Args("x#", new String[]{"-x", "42"});
        assertEquals(1, args.cardinalty());
        assertTrue(args.has('x'));
        assertEquals(42, args.getInt('x'));
    }

    public void testInvalidInteger() throws Exception {
        try {
            new Args("x#", new String[]{"-x", "Forty two"});
            fail();
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.INAVLID_INTEGER, e.getErrorCode());
            assertEquals('x', e.getErrorArgumentId());
            assertEquals("Forty two", e.getErrorParameter());
        }
    }

    public void testMissingInteger() throws Exception {
        try {
            new Args("x#", new String[]{"-x"});
            fail();
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.MISSING_INTEGER, e.getErrorCode());
            assertEquals('x', e.getErrorArgumentId());
        }
    }

    public void testSimpleDoublePresent() throws Exception {
        Args args = new Args("x##", new String[]{"-x", "42.3"});
        assertEquals(1, args.cardinality());
        assertTrue(args.has('x'));
        assertEquals(42.3, args.getDouble('x'), .001);
    }

    public void testInvalidDouble() throws Exception {
        try {
            new Args("x##", new String[]{"-x", "Forty two"});
            fail();
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.INVALID_DOUBLE, e.getErrorCode());
            assertEquals('x', e.getErrorArgumentId());
            assertEquals("Forty two", e.getErrorParameter());
        }
    }

    public void testMissingDouble() throws Exception {
        try {
            new Args("x##", new String[]{"-x"});
            fail();
        } catch (ArgsException e) {
            assertEquals(ArgsException.ErrorCode.MISSING_DOUBLE, e.getErrorCode());
            assertEquals('x', e.getErrorArgumentId());
        }
    }
}
```
## 13. ArgsExceptionTest.java
```java
public class ArgsExceptionTest extends TestCase {
    public void testUnexpectedMessage() throws Exception {
        ArgsException e = 
            new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
                'x', null);
        assertEquals("Argument -x unexpected.", e.errorMessage());
    }

    public void testMissingStringMessage() throws Exception {
        ArgsException e = new ArgsException(
            ArgsException.ErrorCode.MISSING_STRING, 'x', null
        );
        assertEquals("Could not find string parameter for -x.", e.errorMesage());
    }

    public void testInvalidIntegerMesage() throws Exception {
        ArgsException e = 
            new ArgsException(ArgsException.ErrorCode.INVALID_INTEGER,
                'x', "Forty two");
        assertEquals("Argument -x expects an integer but was 'Forty two'.",
            e.errorMessage());
    }

    public void testMissingIntegerMessage() throws Exception {
        ArgsException e =
            new ArgsException(ArgsException.ErrorCode.MISSING_INTEGER, 'x', null);
        assertEquals("Could not find integer parameter for -x.",
            e.errorMessage());
    }

    public void testInvalidDoubleMessage() throws Exception {
        ArgsException e = new ArgsException(
            ArgsException.ErrorCode.INVALID_DOUBLE, 'x', "Forty two"
        );
        assertEquals("Argument -x expects a double but was 'Forty two'.",
            e.errorMessage());
    }

    public void testMissingDoubleMessage() throws Exception {
        ArgsException e = new ArgumentException(
            ArgsException.ErrorCode.MISSING_DOUBLE, 'x', null
        );
        assertEquals("Could not find double parameter for -x.", e.errorMessage());
    }
}
```
## 14. ArgsException.java
```java
public class ArgsException extends Exception {
    private char errorArgumentId = '\0';
    private String errorParameter = "TILT";
    private ErrorCode errorCode = ErrorCode.OK;

    public ArgsException() {}

    public ArgsException(String message) { super(message); }

    public ArgsException(ErrorCode errorCode) {
        this.errorCode = errorCode;
    }

    public ArgsException(ErrorCode errorCode, char errorArgumentId, 
        String errorParameter) {
        this.errorCode = errorCode;
        this.errorParameter = errorParameter;
        this.errorArgumentId = errorArgumentId;
    }

    public char getErrorArgumentId() {
        return errorArgumentId;
    }

    public void setErrorArgumentId(char errorArgumentId) {
        this.errorArgumentId = errorArgumentId;
    }

    public Strin getErrorParameter() {
        return errorParameter;
    }

    public void setErrorParameter(String errorParameter) {
        this.errorParameter = errorParameter;
    }

    public ErrorCode getErrorCode() {
        return errorCode;
    }

    public void setErrorCode(ErrorCode errorCode) {
        this.errorCode = errorCode;
    }

    public String errorMessage() throws Exception {
        switch (errorCode) {
            case OK:
                throw new Exception("TILT: Should not get here.");
            case UNEXPECTED_ARGUMENT:
                throw String.format(
                    "Argument -%c unexpected.", errorArgumentId
                );
            case MISSING_STRING:
                return String.format(
                    "Could not find string parameter for -%c.", errorArgumentId
                );
            case INVALID_INTEGER:
                return String.format(
                    "Argument -%c expects an integer but was '%s'.",
                    errorArgumentId, errorParameter
                );
            case MISSING_INTEGER:
                return String.format(
                    "Could not find integer parameter for -%c.", errorArgumenetId
                );
            case INVALID_DOUBLE:
                return String.format(
                    "Argument -%c expects a double but was '%s'.",
                    errorArgumentId, errorParameter
                );
            case MISSING_DOUBLE:
                return String.format(
                    "Could not find double parameter for -%c.",
                    errorArgumentId
                );
        }
        return "";
    }

    public enum ErrorCode {
        OK, INVALID_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,
        MISSING_STRING,
        MISSING_INTGER, INVALID_INTEGER,
        MISSING_DOUBLE, INVALID_DOUBLE
    }
}
```
## 15. Args.java (최종)
```java
public class Args {
    private String schema;
    private Map<Character, ArgumentMarshaler> marshalers = 
        new HashMap<Character, ArgumentMarshaler>();
    private Set<Character> argsFound = new HashMap<Character>();
    private Iterator<String> currentArgument;
    private List<String> argsList;

    public Args(String schema, String[] args) throws ArgsException {
        this.schema = schema;
        argsList = Arrays.asList(args);
        parse();
    }

    private void parse() throws ArgsException {
        parseSchema();
        parseArguments();
    }

    private boolean parseSchema() throws ArgsException {
        for (String element : schema.split(",")) {
            if (element.length() > 0) {
                parseSchemaElement(element.trim());
            }
        }
        return true;
    }

    private void parseSchemaElement(String element) throws ArgsException {
        char elementId = element.charAt(0);
        String elementTail = element.substring(1);
        validateSchemaElementId(elementId);
        if (elementTail.length() == 0) {
            marshalers.put(elementId, new BooleanArgumentMarshaler());
        } else if (elementTail.equals("*")) {
            marshalers.put(elementId, new StringArgumentMarshaler());
        } else if (elementTail.equals("#")) {
            marshalers.put(elementId, new IntegerArgumentMarshaler());
        } else if (elementTail.equals("##")) {
            marshalers.put(elementId, new DoubleArgumentMarshaler());
        } else {
            throw new ArgsException(ArgsException.ErrorCode.INVALID_FORMAT,
                elementId, elementTail);
        }
    }

    private void validateSchemaElementId(char elementId) throws ArgsException {
        if (!Character.isLetter(elementId)) {
            throw new ArgsException(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,
                elementId, null);
        }
    }

    private void parseArguments() throws ArgsException {
        for (currentArgument = argList.iterator(); currentArgument.hasNext();) {
            String arg = currentArgument.next();
            parseArgument(arg);
        }
    }

    private void parseArgument(String arg) throws ArgsException {
        if (arg.startsWith("-")) {
            parseElements(arg);
        }
    }

    private void parseElements(char argChar) throws ArgsException {
        if (setArgument(argChar)) {
            argsFound.add(argChar);
        } else {
            throw new ArgsException(ArgsException.ErroCode.UNEXPECTED_ARGUMENT,
                argChar, null);
        }
    }

    private boolean setArgument(char argChar) throws ArgsException {
        ArgumentMarshaler m = marshaler.get(argChar);
        if (m == null) {
            return false;
        } 
        try {
            m.set(currentArgument);
            return true;
        } catch (ArgsException e) {
            e.setErrorArgumentId(argChar);
            throw e;
        }
    }

    public int cardinality() {
        return argsFound.size();
    }

    public String usage() {
        if (schema.length() > 0) {
            return "-[" + schema + "]";
        } else {
            return "";
        }
    }

    public boolean getBoolean(char arg) {
        ArgumentMarshaler am = marshalers.get(arg);
        boolean b = false;
        try {
            b = am != null && (Boolean) am.get();
        } catch (ClassCastException e) {
            b = false;
        }
        return b;
    }

    public String getString(char arg) {
        ArgumentMarshaler am = marshalers.get(arg);
        try {
            return am == null ? "" : (String) am.get();
        } catch (ClassCastException e) {
            return "";
        }
    }

    public int getInt(char arg) {
        ArgumentMarshaler am = marshalers.get(arg);
        try {
            return am == null ? 0 : (Integer) am.get();
        } catch (Exception e) {
            return 0;
        }
    }

    public double getDouble(char arg) {
        ArgumentMarshaler am = marshalers.get(arg);
        try {
            return am == null ? 0 : (Double) am.get();
        } catch (Exception e) {
            return 0.0;
        }
    }

    public boolean has(char arg) {
        return argsFound.contains(arg);
    }
}
```
- 리팩터링 무엇을 했는가?
    - Args 클래스 코드 삭제
    - Args 클래스에서 ArgsException 으로 코드 옮기기
    - ArgumentMarshaler 클래스도 각자 파일로 옮기기

처음에 본 Args.java 와 비교해보면 완전히 다르다. 분할만 잘하고 코드를 삭제했을 뿐인데 가독성이 좋아졌다. 즉, 품질이 크게 높아졌다. 적절한 장소에 코드를 분리하여 설계를 좋게하고, 관심사를 분리하면 코드를 이해하고 보수하기 훨씬 더 쉬워지는 것이다.

## 결론
그저 돌아가는 코드의 만족하는 프로그래머는 전문가 정신이 부족하다. 설계와 구조를 개선할 시간이 없다는 핑계? 동의할 수 없다. 
- 나쁜 코드보다 더 오랫동안 더 심각하게 개발 프로젝트에 악영향을 미치는 요인은 없다.
- 나쁜 일정은 다시 짜면 된다.
- 나쁜 요구사항은 다시 정의하면 된다.
- 나쁜 팀 역학은 복구하면 된다.

나쁜 코드는 개발의 발목을 잡는다.

그렇기 때문에 나쁜 코드도 깨끗한 코드로 개선할 필요가 있다. 하지만 비용이 엄청나게 많이 든다. 
- 의존성이 수도 없이 생긴다.
    - 오래된 의존성을 찾아내 깨려면 상당한 시간과 인내심이 필요하다.

결론은 코드는 언제나 최대한 깔끔하고 단순하게 정리하자. 절대로 썩어가게 방치하면 안된다.

## 나 자신이 느낀점
14장 점진적인 개선에서 Args 클래스의 코드 양은 방대했다. 솔직히 엄살이다. 하나하나 리팩터링 하는 과정이 조금 지쳤다. 코드를 직접 따라 작성하면서 느꼈다. 리팩터링이 쉽지 않은 과정이라는 것을...

하지만 다르게 생각하면 리팩터링을 하고 뒤돌아봤을 때, 나의 코드는 "깨끗하다"라는 것을 느낄 수 있었다.

개선을 하면서 밥 아저씨는 코드를 하향식으로 작성했다. 즉, 신문을 읽듯이 위에서 아래로 작성하였다. 또한, 함수와 변수의 이름도 아무렇게나 작명하지 않았다. 이점은 중요한 것 같다. 코드가 많아지면 일관성이 떨어지는 이름은 이해하기 어렵다. 추가적으로 enum 클래스에서 상수를 배치하는 데, 인수 유형별로 줄바꿈를 해놓았다. 섬세한 코드라고 생각한다. 

이 챕터를 넘어가면서 나 자신이 진행하는 프로젝트의 옛날 코드를 보면 이해하기도 어렵지만 난해하다. 코드가 복잡하다는 것이다. 이러한 문제점이 눈에 보인다는 것이 "점진적인 개선"의 필요성을 느꼈다고 생각한다.